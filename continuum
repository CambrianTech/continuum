#!/bin/bash
# Continuum CLI - Universal thin client that connects to daemon system
# Handles all deployment scenarios: development, production, homebrew, npm global, local

# Parse arguments for command and session parameters
COMMAND="${1:-connect}"
SESSION_ID=""
SESSION_TYPE=""
OWNER=""
FORCE_NEW=""
FOCUS="true"
KILL_ZOMBIES="true"

# Parse session-related arguments
shift || true  # Remove command from args
while [[ $# -gt 0 ]]; do
  case $1 in
    --session)
      SESSION_ID="$2"
      shift 2
      ;;
    --session-type)
      SESSION_TYPE="$2"
      shift 2
      ;;
    --owner)
      OWNER="$2"
      shift 2
      ;;
    --new)
      FORCE_NEW="true"
      shift
      ;;
    --focus)
      FOCUS="true"
      shift
      ;;
    --no-focus)
      FOCUS="false"
      shift
      ;;
    --kill-zombies)
      KILL_ZOMBIES="true"
      shift
      ;;
    --no-kill-zombies)
      KILL_ZOMBIES="false"
      shift
      ;;
    *)
      # Unknown option, skip
      shift
      ;;
  esac
done

# Function to check if daemon is running
daemon_running() {
  curl -s http://localhost:9000/api/health > /dev/null 2>&1
}

# Function to find continuum installation
find_continuum_installation() {
  # Priority order for finding continuum installation:
  # 1. Current directory (development mode)
  # 2. Script directory (local installation)
  # 3. Homebrew installation
  # 4. npm global installation
  # 5. Common system paths
  
  local candidates=(
    "$(pwd)"                                    # Current directory (development)
    "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"  # Script location
    "/opt/homebrew/lib/node_modules/continuum"  # Homebrew installation
    "/usr/local/lib/node_modules/continuum"     # npm global (Intel Mac)
    "/opt/homebrew/bin/continuum"               # Homebrew binary path
    "/usr/local/bin/continuum"                  # System binary path
    "$HOME/.npm-global/lib/node_modules/continuum"  # User npm global
    "$HOME/continuum"                           # User local installation
  )
  
  for dir in "${candidates[@]}"; do
    if [ -d "$dir" ] && ([ -f "$dir/package.json" ] || [ -f "$dir/main.ts" ] || [ -f "$dir/launch.ts" ]); then
      echo "$dir"
      return 0
    fi
  done
  
  return 1
}

# Function to start daemon system
start_daemon() {
  echo "üîç Searching for Continuum installation..."
  
  local install_dir
  install_dir=$(find_continuum_installation)
  
  if [ $? -ne 0 ] || [ -z "$install_dir" ]; then
    echo "‚ùå Continuum installation not found"
    echo "   Searched common installation paths:"
    echo "   - Current directory: $(pwd)"
    echo "   - Script directory: $(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    echo "   - Homebrew: /opt/homebrew/lib/node_modules/continuum"
    echo "   - npm global: /usr/local/lib/node_modules/continuum"
    echo "   - User paths: ~/.npm-global/lib/node_modules/continuum"
    echo ""
    echo "üí° Install options:"
    echo "   npm install -g continuum     # Global installation"
    echo "   brew install continuum       # Homebrew installation"
    echo "   git clone <repo> && cd continuum && npm install  # Development"
    exit 1
  fi
  
  echo "‚úÖ Found Continuum at: $install_dir"
  cd "$install_dir" || exit 1
  
  # Determine best start method based on what's available
  if [ -f "main.ts" ] && command -v tsx > /dev/null 2>&1; then
    echo "üöÄ Starting Continuum daemon system (TypeScript)..."
    nohup tsx main.ts > /dev/null 2>&1 &
  elif [ -f "launch.ts" ] && command -v npm > /dev/null 2>&1; then
    echo "üöÄ Starting Continuum daemon system (development mode)..."
    nohup npm run dev > /dev/null 2>&1 &
  elif [ -f "package.json" ] && command -v npm > /dev/null 2>&1; then
    echo "üöÄ Starting Continuum daemon system (npm)..."
    if npm run | grep -q "start"; then
      nohup npm start > /dev/null 2>&1 &
    else
      nohup npm run dev > /dev/null 2>&1 &
    fi
  elif [ -f "dist/main.js" ] && command -v node > /dev/null 2>&1; then
    echo "üöÄ Starting Continuum daemon system (compiled)..."
    nohup node dist/main.js > /dev/null 2>&1 &
  else
    echo "‚ùå No suitable start method found"
    echo "   Available files:"
    ls -la main.* launch.* package.json dist/main.* 2>/dev/null || echo "   None found"
    echo "   Available commands:"
    echo "   - tsx: $(command -v tsx || echo 'not found')"
    echo "   - npm: $(command -v npm || echo 'not found')"
    echo "   - node: $(command -v node || echo 'not found')"
    exit 1
  fi
  
  # Wait for daemon OS to be ready with better feedback
  echo "‚è≥ Waiting for daemon system to start..."
  for i in {1..30}; do
    if daemon_running; then
      echo "‚úÖ Daemon system started and responding at http://localhost:9000"
      return 0
    fi
    printf "."
    sleep 1
  done
  
  echo ""
  echo "‚ùå Failed to start daemon system (timeout after 30 seconds)"
  echo "   Check if port 9000 is available:"
  lsof -i :9000 2>/dev/null || echo "   Port 9000 appears to be free"
  return 1
}

# Function to stop daemon system
stop_daemon() {
  echo "üõë Stopping Continuum daemon system..."
  
  # Try graceful shutdown via API first
  if daemon_running; then
    echo "   Attempting graceful shutdown..."
    curl -s -X POST "http://localhost:9000/api/commands/shutdown" \
      -H "Content-Type: application/json" \
      -d '{"args": []}' > /dev/null 2>&1 || true
    sleep 3
  fi
  
  # Force kill if still running
  if daemon_running; then
    echo "   Force stopping processes..."
    # Kill various possible process patterns
    pkill -f "tsx main.ts" 2>/dev/null || true
    pkill -f "tsx launch.ts" 2>/dev/null || true  
    pkill -f "npm run dev" 2>/dev/null || true
    pkill -f "npm start" 2>/dev/null || true
    pkill -f "node.*continuum" 2>/dev/null || true
    
    # Kill processes using port 9000
    lsof -ti:9000 2>/dev/null | xargs kill -9 2>/dev/null || true
    sleep 2
  fi
  
  if daemon_running; then
    echo "‚ö†Ô∏è  Daemon may still be running - check manually with: lsof -i :9000"
  else
    echo "‚úÖ Daemon system stopped"
  fi
}

# Function to get system status
status_daemon() {
  if daemon_running; then
    echo "‚úÖ Continuum daemon system is running at http://localhost:9000"
    echo "üìä System status:"
    curl -s "http://localhost:9000/api/status" 2>/dev/null | head -20 || echo "   Unable to fetch detailed status"
  else
    echo "‚ùå Continuum daemon system is not running"
    echo "üîç Checking for zombie processes on port 9000:"
    lsof -i :9000 2>/dev/null || echo "   No processes found on port 9000"
  fi
}

# Handle version
if [ "$COMMAND" = "--version" ] || [ "$COMMAND" = "-v" ] || [ "$COMMAND" = "version" ]; then
  # Check if daemon is running
  if daemon_running; then
    # Get version from API
    VERSION=$(curl -s "http://localhost:9000/api/version" 2>/dev/null | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
    if [ -n "$VERSION" ]; then
      echo "continuum $VERSION"
      exit 0
    fi
  fi
  
  # Fallback to local package.json
  install_dir=$(find_continuum_installation)
  if [ -n "$install_dir" ] && [ -f "$install_dir/package.json" ]; then
    VERSION=$(grep '"version"' "$install_dir/package.json" | head -1 | cut -d'"' -f4)
  else
    VERSION="unknown"
  fi
  echo "continuum $VERSION"
  exit 0
fi

# Handle explicit daemon management commands 
case "$COMMAND" in
  "start")
    if daemon_running; then
      echo "‚úÖ Continuum daemons already running at http://localhost:9000"
    else
      start_daemon
    fi
    exit 0
    ;;
  "stop")
    if daemon_running; then
      stop_daemon
    else
      echo "‚úÖ Continuum daemons already stopped"
    fi
    exit 0
    ;;
  "restart")
    if daemon_running; then
      stop_daemon
    fi
    start_daemon
    exit 0
    ;;
  "status")
    status_daemon
    exit 0
    ;;
  "help"|"--help"|"-h"|"")
    echo "Continuum CLI - Universal thin client with session management"
    echo ""
    echo "Usage:"
    echo "  continuum [command] [options]"
    echo ""
    echo "Commands:"
    echo "  <default>               Open Continuum in browser (auto-starts daemons)"
    echo "  start                   Start daemon system"
    echo "  stop                    Stop daemon system"  
    echo "  restart                 Restart daemon system"
    echo "  status                  Show daemon status"
    echo "  health                  Check system health"
    echo "  version, --version      Show version"
    echo "  help, --help            Show this help"
    echo ""
    echo "Session Options:"
    echo "  --session ID            Connect to specific session ID"
    echo "  --session-type TYPE     Session type (development, persona, etc.)"
    echo "  --owner OWNER           Session owner (default: shared)"
    echo "  --new                   Force create new session"
    echo "  --focus                 Focus browser window (default for bash)"
    echo "  --no-focus              Don't focus browser window"
    echo "  --kill-zombies          Close zombie browser tabs (default for shared)"
    echo "  --no-kill-zombies       Keep all browser tabs"
    echo ""
    echo "Examples:"
    echo "  continuum                        # Open browser and connect"
    echo "  continuum --new                  # Create new session"
    echo "  continuum status                 # Check if daemons are running"
    exit 0
    ;;
esac

# For all other commands (including connect), ensure daemon is running and call via API
if ! daemon_running; then
  echo "üöÄ Auto-starting Continuum daemon system..."
  start_daemon || exit 1
fi

# Build request payload with session parameters
request_data="{"

# Add session parameters if provided
if [ -n "$SESSION_ID" ]; then
  request_data="$request_data\"sessionId\": \"$SESSION_ID\", "
fi

if [ -n "$SESSION_TYPE" ]; then
  request_data="$request_data\"sessionType\": \"$SESSION_TYPE\", "
else
  request_data="$request_data\"sessionType\": \"development\", "
fi

if [ -n "$OWNER" ]; then
  request_data="$request_data\"owner\": \"$OWNER\", "
else
  request_data="$request_data\"owner\": \"shared\", "
fi

if [ -n "$FORCE_NEW" ]; then
  request_data="$request_data\"forceNew\": true, "
else
  request_data="$request_data\"forceNew\": false, "
fi

if [ "$FOCUS" = "true" ]; then
  request_data="$request_data\"focus\": true, "
else
  request_data="$request_data\"focus\": false, "
fi

if [ "$KILL_ZOMBIES" = "true" ]; then
  request_data="$request_data\"killZombies\": true"
else
  request_data="$request_data\"killZombies\": false"
fi

request_data="$request_data}"

# Special handling for connect command (default)
if [ "$COMMAND" = "connect" ]; then
  response=$(curl -s -X POST "http://localhost:9000/api/commands/$COMMAND" \
    -H "Content-Type: application/json" \
    -d "$request_data" 2>/dev/null)
  
  if [ $? -eq 0 ] && [ -n "$response" ]; then
    # Debug: show raw response
    # echo "DEBUG: Raw response: $response"
    
    # Parse the response
    if command -v jq > /dev/null 2>&1; then
      # Check if response has sessionId at top level (new format)
      if echo "$response" | jq -e '.sessionId' > /dev/null 2>&1; then
        SESSION_ID=$(echo "$response" | jq -r '.sessionId')
        ACTION=$(echo "$response" | jq -r '.action')
        INTERFACE=$(echo "$response" | jq -r '.interface')
        BROWSER_LAUNCHED=$(echo "$response" | jq -r '.launched.browser')
        VERSION=$(echo "$response" | jq -r '.version // "unknown"')
        SERVER_LOG=$(echo "$response" | jq -r '.logs.server // ""')
        BROWSER_LOG=$(echo "$response" | jq -r '.logs.browser // ""')
        
        # Get current directory for full path display
        PROJECT_DIR=$(pwd)
        
        # Show user-friendly output
        echo ""
        echo "üéâ Connected to Continuum v$VERSION"
        echo "   Session: $SESSION_ID"
        echo "   Status:  $ACTION"
        echo "   URL:     $INTERFACE"
        echo ""
        echo "üìÇ Project: $PROJECT_DIR"
        echo ""
        echo "üìã Session Logs:"
        echo "   Server:  tail -f $SERVER_LOG"
        echo "   Browser: tail -f $BROWSER_LOG"
        echo ""
        
        # Check if browser should launch
        if [ "$BROWSER_LAUNCHED" = "true" ]; then
          echo "üåê Browser launching..."
        fi
      else
        # Error response
        ERROR=$(echo "$response" | jq -r '.error // "Unknown error"')
        echo "‚ùå Connection failed: $ERROR"
        # Debug: show what we got
        echo "DEBUG: Response was: $response"
        exit 1
      fi
    else
      # No jq, just show raw response
      echo "$response"
    fi
  else
    echo "‚ùå Failed to connect to daemon"
    echo "üîç Checking daemon status..."
    status_daemon
    exit 1
  fi
else
  # For other commands, call via API
  echo "üåê Executing command: $COMMAND"
  if [ -n "$SESSION_ID" ] || [ -n "$SESSION_TYPE" ] || [ -n "$OWNER" ] || [ -n "$FORCE_NEW" ]; then
    echo "   Session parameters: sessionId=$SESSION_ID, type=$SESSION_TYPE, owner=$OWNER, forceNew=$FORCE_NEW"
  fi

  response=$(curl -s -X POST "http://localhost:9000/api/commands/$COMMAND" \
    -H "Content-Type: application/json" \
    -d "$request_data" 2>/dev/null)

  if [ $? -eq 0 ] && [ -n "$response" ]; then
    # Pretty print JSON if possible
    if command -v jq > /dev/null 2>&1; then
      echo "$response" | jq .
    else
      echo "$response"
    fi
  else
    echo "‚ùå Command failed or daemon not responding"
    echo "üîç Checking daemon status..."
    status_daemon
    exit 1
  fi
fi