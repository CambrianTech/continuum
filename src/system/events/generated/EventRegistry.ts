/**
 * Event Registry - Runtime Event Discovery and Metadata
 * 
 * ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by EventConstantsGenerator at 2025-08-17T00:41:55.944Z
 * 
 * Provides runtime access to event metadata for dynamic subscription,
 * debugging, and introspection capabilities.
 */

export interface EventMetadata {
  name: string;
  fullName: string;
  namespace: string;
  scope: 'system' | 'room' | 'user' | 'global';
  daemon: string;
}

/**
 * Runtime Event Registry - All JTAG events with metadata
 */
export const EVENT_REGISTRY: Record<string, EventMetadata> = {
  'console.attached': {
    name: 'ATTACHED',
    fullName: 'console.attached',
    namespace: 'console',
    scope: 'global',
    daemon: 'console'
  },
  'console.queue-drain-start': {
    name: 'QUEUE_DRAIN_START',
    fullName: 'console.queue-drain-start',
    namespace: 'console',
    scope: 'global',
    daemon: 'console'
  },
  'console.queue-drain-complete': {
    name: 'QUEUE_DRAIN_COMPLETE',
    fullName: 'console.queue-drain-complete',
    namespace: 'console',
    scope: 'global',
    daemon: 'console'
  },
  'console.message-processed': {
    name: 'MESSAGE_PROCESSED',
    fullName: 'console.message-processed',
    namespace: 'console',
    scope: 'global',
    daemon: 'console'
  },
  'command.registered': {
    name: 'REGISTERED',
    fullName: 'command.registered',
    namespace: 'command',
    scope: 'global',
    daemon: 'command'
  },
  'command.executed': {
    name: 'EXECUTED',
    fullName: 'command.executed',
    namespace: 'command',
    scope: 'global',
    daemon: 'command'
  },
  'command.failed': {
    name: 'FAILED',
    fullName: 'command.failed',
    namespace: 'command',
    scope: 'global',
    daemon: 'command'
  },
  'system.initializing': {
    name: 'INITIALIZING',
    fullName: 'system.initializing',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'system.daemons.loading': {
    name: 'DAEMONS_LOADING',
    fullName: 'system.daemons.loading',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'system.daemons.loaded': {
    name: 'DAEMONS_LOADED',
    fullName: 'system.daemons.loaded',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'system.transport.ready': {
    name: 'TRANSPORT_READY',
    fullName: 'system.transport.ready',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'system.ready': {
    name: 'READY',
    fullName: 'system.ready',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'system.shutdown': {
    name: 'SHUTDOWN',
    fullName: 'system.shutdown',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'system.error': {
    name: 'ERROR',
    fullName: 'system.error',
    namespace: 'system',
    scope: 'system',
    daemon: 'system'
  },
  'health.update': {
    name: 'HEALTH_UPDATE',
    fullName: 'health.update',
    namespace: 'system',
    scope: 'global',
    daemon: 'system'
  },
  'transport.ready': {
    name: 'READY',
    fullName: 'transport.ready',
    namespace: 'transport',
    scope: 'global',
    daemon: 'transport'
  },
  'transport.connected': {
    name: 'CONNECTED',
    fullName: 'transport.connected',
    namespace: 'transport',
    scope: 'global',
    daemon: 'transport'
  },
  'transport.disconnected': {
    name: 'DISCONNECTED',
    fullName: 'transport.disconnected',
    namespace: 'transport',
    scope: 'global',
    daemon: 'transport'
  },
  'transport.error': {
    name: 'ERROR',
    fullName: 'transport.error',
    namespace: 'transport',
    scope: 'global',
    daemon: 'transport'
  }
};

/**
 * Event Registry Utilities
 */
export class EventRegistryUtils {
  /**
   * Get all events for a specific daemon
   */
  static getEventsForDaemon(daemon: string): EventMetadata[] {
    return Object.values(EVENT_REGISTRY).filter(e => e.daemon === daemon);
  }
  
  /**
   * Get all events by scope
   */
  static getEventsByScope(scope: EventMetadata['scope']): EventMetadata[] {
    return Object.values(EVENT_REGISTRY).filter(e => e.scope === scope);
  }
  
  /**
   * Get event metadata by full name
   */
  static getEventMetadata(fullName: string): EventMetadata | undefined {
    return EVENT_REGISTRY[fullName];
  }
  
  /**
   * Check if event name is valid
   */
  static isValidEvent(eventName: string): boolean {
    return eventName in EVENT_REGISTRY;
  }
  
  /**
   * Get all available event names
   */
  static getAllEventNames(): string[] {
    return Object.keys(EVENT_REGISTRY);
  }
  
  /**
   * Get events summary by daemon and scope
   */
  static getEventsSummary(): Record<string, Record<string, number>> {
    const summary: Record<string, Record<string, number>> = {};
    
    for (const event of Object.values(EVENT_REGISTRY)) {
      if (!summary[event.daemon]) {
        summary[event.daemon] = { system: 0, room: 0, user: 0, global: 0 };
      }
      summary[event.daemon][event.scope]++;
    }
    
    return summary;
  }
}
