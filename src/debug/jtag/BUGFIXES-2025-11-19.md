# Bug Fixes - 2025-11-19

## Discovered by AI Team Exploration

The AI team discovered several critical bugs while exploring the system using the newly-fixed help command. These issues prevent basic functionality and need immediate attention.

---

## P0 - Critical Bugs

### 1. data/list - undefined replace() error

**Bug**: Command fails with "Cannot read properties of undefined (reading 'replace')"
**Discovered by**: Grok (AI team member)
**Command**: `./jtag data/list --collection=users`

**Error Details**:
- CLI parameter parsing has unsafe `.replace()` call
- Location: `cli.ts:163` - `const argWithoutDashes = arg.replace(/^--/, '');`
- Despite error, helpfully reveals collection list in error message

**Root Cause Analysis**:
The parameter parsing code assumes `arg` is always defined, but in some cases (likely empty array elements or parsing edge cases) `arg` can be undefined.

**Fix**:
Add null check before calling `.replace()`:
```typescript
if (arg?.startsWith('--')) {
  const argWithoutDashes = arg.replace(/^--/, ''); // Safe - we know arg exists
  // ... rest of logic
}
```

**Alternatively** - use defensive programming:
```typescript
const argWithoutDashes = arg?.replace(/^--/, '') || '';
```

**Test Plan**:
```bash
./jtag data/list --collection=users
./jtag data/list --collection=chat_messages --limit=10
./jtag data/list  # Test without collection parameter
```

---

### 2. data/query-next - orderBy mapping error

**Bug**: Command fails with "state.orderBy?.map is not a function"
**Discovered by**: Claude Assistant, DeepSeek Assistant
**Command**: `./jtag data/query-next --queryHandle=query-1`

**Error Details**:
- Query state not properly initialized
- `orderBy` parameter is malformed (not an array when expected)
- Pagination is broken

**Root Cause Analysis**:
The query state created by `data/query-open` doesn't properly serialize/deserialize the `orderBy` parameter, or the parameter is being passed as a single object instead of an array.

**Investigation Needed**:
1. Check `data/query-open` - how is `orderBy` stored in query state?
2. Check `data/query-next` - how is `orderBy` retrieved from state?
3. Check if JSON serialization is breaking the array structure

**Potential Fix Locations**:
- `commands/data/query-open/server/QueryOpenServerCommand.ts`
- `commands/data/query-next/server/QueryNextServerCommand.ts`
- Query state storage in DataDaemon

**Test Plan**:
```bash
# Open query with orderBy
./jtag data/query-open --collection=chat_messages \
  --orderBy='[{"field":"timestamp","direction":"desc"}]'

# Fetch next page
./jtag data/query-next --queryHandle=<handle-from-above>
```

---

### 3. Query handle persistence - handles not found

**Bug**: Query handles don't persist between command invocations
**Discovered by**: Claude Assistant, DeepSeek Assistant
**Command**: `./jtag data/query-next --queryHandle=query-1`

**Error**: "Query handle 'query-1' not found"

**Root Cause Analysis**:
Query handles created by `data/query-open` are not being stored in a way that persists across separate command executions. Each command execution might be using a new session or the handles are stored in command-local state that doesn't survive.

**Architectural Issue**:
Query handles need to be stored in:
1. Server-side session state (per sessionId)
2. Or in a daemon with persistent storage
3. Or returned with every response for client-side tracking

**Investigation Needed**:
1. Where are query handles currently stored?
2. Is there session-based storage available?
3. Should handles expire after a timeout?

**Potential Solutions**:
1. Store handles in DataDaemon with session affinity
2. Add session-based query state storage
3. Document handle lifecycle and expiration

**Test Plan**:
```bash
# Test 1: Basic pagination
HANDLE=$(./jtag data/query-open --collection=chat_messages --pageSize=5 | jq -r '.queryHandle')
./jtag data/query-next --queryHandle="$HANDLE"
./jtag data/query-next --queryHandle="$HANDLE"  # Second page

# Test 2: Multiple concurrent queries
HANDLE1=$(./jtag data/query-open --collection=users --pageSize=3 | jq -r '.queryHandle')
HANDLE2=$(./jtag data/query-open --collection=rooms --pageSize=3 | jq -r '.queryHandle')
./jtag data/query-next --queryHandle="$HANDLE1"
./jtag data/query-next --queryHandle="$HANDLE2"
```

---

## P1 - High Priority Bugs

### 4. RAG System - Multiple initialization failures

**Bugs**: All RAG commands fail with undefined property errors
**Discovered by**: Claude Assistant, Groq Lightning, Grok, multiple AI team members

**Affected Commands**:
- `ai/rag/inspect` - "Cannot read properties of undefined (reading 'slice')"
- `ai/rag/index/create` - "Cannot read properties of undefined (reading 'length')"
- `ai/rag/query-open` - Returns 0 results (empty index)
- `ai/rag/load` - Unclear required parameters (needs roomId or room)

**Root Cause Analysis**:
The RAG system has fundamental initialization issues:
1. RAG infrastructure not properly initialized on startup
2. Missing dependencies or configuration
3. No clear indication that RAG is unavailable
4. Error messages don't help diagnose the problem

**Investigation Needed**:
1. What initializes the RAG system?
2. Is there a RAG daemon that needs to start?
3. Are embedding models required but not loaded?
4. Is there a configuration file missing?

**Enhancement: RAG Health Check**
Add `ai/rag/status` or enhance `ai/status` to report:
- RAG system initialized: yes/no
- Index exists: yes/no
- Document count: N
- Embedding model: loaded/not loaded
- Last index update: timestamp

**Test Plan**:
```bash
# Test 1: Health check
./jtag ai/status  # Should show RAG status

# Test 2: Index creation
./jtag ai/rag/index/create --source="docs" --name="documentation"

# Test 3: Document loading
./jtag ai/rag/load --roomId="<room-id>" --fileType="markdown"

# Test 4: Query
./jtag ai/rag/query-open --query="TypeScript compiler" --minRelevance=0.7

# Test 5: Inspection
./jtag ai/rag/inspect --index="documentation"
```

---

## P2 - Enhancements

### 5. Error Messages - Unclear required parameters

**Issue**: Error messages don't specify which parameters are required
**Example**: `ai/rag/load` - Fails but doesn't say "Missing required parameter: roomId or room"

**Enhancement**:
All commands should use consistent error format:
```json
{
  "success": false,
  "error": "Missing required parameter: roomId or room",
  "hint": "Example: ./jtag ai/rag/load --roomId=<id> --fileType=markdown"
}
```

**Implementation**:
1. Add parameter validation to CommandBase
2. Use help command schemas to determine required parameters
3. Generate helpful error messages with examples

---

### 6. data/list Enhancement - Clean collection list

**Issue**: Currently fails with error but includes collection list in error message
**Current behavior**: Error with helpful data leak
**Desired behavior**: Clean, structured response

**Enhancement**:
```bash
# Without collection parameter
./jtag data/list

# Should return:
{
  "success": true,
  "collections": [
    "users",
    "user_states",
    "rooms",
    "chat_messages",
    "artifacts",
    "sessions",
    "tasks",
    "coordination_decisions",
    "cognition_state_snapshots",
    "cognition_plan_records"
  ]
}
```

---

## Completed Fixes (2025-11-20)

### ✅ Bug #1: data/list - undefined replace() error
**Status**: Fixed and deployed
**Fixed by**: Claude Code
**Deployed**: v1.0.5075

**What was done**:
- Changed `cli.ts:162` from `arg?.startsWith('--')` to `arg && arg.startsWith('--')`
- This ensures proper null safety before calling `.replace()`
- Optional chaining doesn't properly narrow types for subsequent operations

**Testing**:
```bash
./jtag data/list --collection=users  # ✅ Works
./jtag data/list --collection=chat_messages --limit=10  # ✅ Works
```

### ✅ Enhancement: Ollama Queue Overflow Fix
**Status**: Fixed and deployed
**Fixed by**: Claude Code
**Deployed**: v1.0.5075

**Problem**:
- 13 AI personas responding simultaneously overwhelmed Ollama request queue
- maxConcurrent=4 was too low for system load
- Local Assistant outputting "@@@" timeouts instead of responses

**Solution**:
- Increased `maxConcurrent` from 4 → 12 in `OllamaAdapter.ts`
- Changed both constructor default and queue initialization

**Testing**: Local Assistant now responds normally without timeout errors

### ✅ Phase 1A: Git Commands Implementation
**Status**: Implemented and deployed
**Developed by**: Claude Code based on AI team feedback
**Deployed**: v1.0.5081

**What was implemented**:

1. **git/issue/create** - Create GitHub issues via gh CLI
   - Parameters: title, body, labels, assignee, milestone
   - Two-step process: create (get URL) → view (fetch details)
   - Validation: checks gh CLI installed and authenticated
   - Error handling: proper shell escaping and timeout management
   - **Test result**: Created and closed issue #174 successfully

2. **git/issue/list** - List GitHub issues with filtering
   - Parameters: state (open/closed/all), label, assignee, limit
   - Returns: Full issue details with metadata
   - **Test result**: Successfully lists issues with proper JSON output

**Files Created**:
- `commands/git/GIT-COMMANDS-ROADMAP.md` (641 lines) - Complete roadmap
- `commands/git/IMPLEMENTATION-PLAN.md` (400 lines) - Phase 1A spec
- `commands/git/issue/create/shared/GitIssueCreateTypes.ts` - Type definitions
- `commands/git/issue/create/server/GitIssueCreateServerCommand.ts` - Server implementation
- `commands/git/issue/create/browser/GitIssueCreateBrowserCommand.ts` - Browser pass-through
- `commands/git/issue/list/shared/GitIssueListTypes.ts` - Type definitions
- `commands/git/issue/list/server/GitIssueListServerCommand.ts` - Server implementation
- `commands/git/issue/list/browser/GitIssueListBrowserCommand.ts` - Browser pass-through

**AI Team Involvement**:
- AI team requested git commands for issue tracking
- Voted unanimously for Phase 1A (create + list) as first priority
- Provided feedback on command design and priorities
- Notified of completion via chat

**Next Phase**: Phase 1B (git/issue/comment, git/issue/update, git/issue/get)

---

## Implementation Priority

**Immediate (This Session)**:
1. ✅ Fix data/list replace() error (COMPLETED)
2. ✅ Fix ollama queue overflow (COMPLETED)
3. ✅ Implement git/issue/create and git/issue/list (COMPLETED)
4. ⏱️  Add RAG health check command (30 min)

**Next Session**:
5. Fix data/query-next orderBy error
6. Fix query handle persistence
7. Investigate RAG initialization
8. Implement Phase 1B git commands (comment, update, get)

**Future**:
9. Enhance error messages across all commands
10. Add parameter validation framework
11. Document query handle lifecycle
12. Add AI attribution to git issue bodies

---

## Testing Strategy

**Phase 1: Fix and Verify**
- Fix each bug
- Write unit test if applicable
- Test manually with AI team's original commands

**Phase 2: Regression Testing**
- Re-run AI team's exploration commands
- Verify all help command outputs still work
- Check no new bugs introduced

**Phase 3: AI Team Validation**
- Let AI team explore again
- Monitor chat for new discoveries
- Document any additional issues

---

## Success Criteria

1. ✅ `./jtag data/list --collection=users` works without errors
2. ✅ `./jtag ai/status` shows RAG health information
3. ✅ `./jtag data/query-open` → `data/query-next` pagination works
4. ✅ RAG commands either work or fail with helpful error messages
5. ✅ AI team can explore system without hitting critical bugs

---

## AI Team Feedback Loop

The AI team's systematic exploration discovered these bugs because they:
1. Used the newly-fixed help command to understand parameters
2. Tried commands with proper parameters
3. Hit errors and reported them clearly
4. Collaborated to troubleshoot and find workarounds

**Key Insight**: Proper documentation (help command) enabled effective QA testing by the AI team. They're now our best bug hunters!

**Next Steps**:
- Fix P0 bugs
- Let AI team re-test
- Create feedback loop for continuous improvement
