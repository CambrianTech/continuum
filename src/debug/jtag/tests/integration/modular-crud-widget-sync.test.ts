/**
 * Modular CRUD-Widget Synchronization Test
 *
 * Tests the React-like reactivity: CRUD Operation â†’ DB Update â†’ Event Emission â†’ Widget HTML Update
 * Works for any (Collection, Widget) combination without timeouts
 */

import { execSync } from 'child_process';

console.log('ğŸ§ª MODULAR CRUD-WIDGET SYNCHRONIZATION TEST');
console.log('============================================');

interface TestConfig {
  collection: string;
  widget: string;
  testId: string;
  updateData: Record<string, any>;
  verifyField: string;
  expectedValue: string;
}

interface TestResult {
  step: string;
  success: boolean;
  details?: Record<string, unknown>;
  error?: string;
}

const results: TestResult[] = [];

async function runJtagCommand(command: string): Promise<Record<string, unknown>> {
  try {
    const output = execSync(`./jtag ${command}`, {
      encoding: 'utf8',
      cwd: '/Volumes/FlashGordon/cambrian/continuum/src/debug/jtag'
    });

    // Parse JTAG JSON response
    const lines = output.split('\n');
    const resultLine = lines.find(line => line.includes('COMMAND RESULT:'));
    if (resultLine) {
      const jsonStart = output.indexOf('{', output.indexOf('COMMAND RESULT:'));
      const jsonEnd = output.lastIndexOf('}') + 1;
      return JSON.parse(output.substring(jsonStart, jsonEnd));
    }
    return {};
  } catch (error) {
    console.error(`âŒ Command failed: ${command}`);
    console.error(error instanceof Error ? error.message : String(error));
    throw error;
  }
}

/**
 * Modular test function for any Collection-Widget pair WITH PROPER VALIDATION
 */
async function testCRUDWidgetSync(config: TestConfig): Promise<void> {
  console.log(`\nğŸ“‹ TESTING: ${config.collection} â†” ${config.widget}`);
  console.log('------------------------------------------------');

  try {
    // Step 1: TEST PROPER ENTITY CREATION WITH data/create
    console.log('ğŸ” Step 1: Testing proper entity creation...');

    // Create proper entity data - NO MALFORMED STRINGS!
    const testEntityData = config.collection === 'ChatMessage' ? {
      roomId: config.testId,
      senderId: "002350cc-0031-408d-8040-004f000f",
      senderName: "TestBot",
      content: { text: "TEST ENTITY VALIDATION MESSAGE", attachments: [] },
      status: "sent",
      priority: "normal"
      // timestamp will be auto-generated by ChatMessageEntity constructor
    } : config.collection === 'User' ? {
      displayName: "Test Entity Validation User",
      email: "test-validation@example.com",
      status: "active"
    } : config.updateData;

    const createCommand = `data/create --collection=${config.collection} --data='${JSON.stringify(testEntityData)}'`;
    const createResult = await runJtagCommand(createCommand);

    // VALIDATE PROPER ENTITY CREATION
    const entityId = createResult.id || createResult.data?.id;
    const isValidUUID = entityId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(entityId);

    console.log(`   Created entity ID: ${entityId}`);
    console.log(`   Valid UUID: ${isValidUUID ? 'YES' : 'NO'}`);
    console.log(`   Create success: ${createResult.success ? 'YES' : 'NO'}`);

    results.push({
      step: `${config.collection} Entity Creation Validation`,
      success: Boolean(createResult.success && isValidUUID),
      details: {
        entityId,
        isValidUUID,
        createSuccess: createResult.success
      }
    });

    if (!createResult.success || !isValidUUID) {
      throw new Error(`Entity creation failed or invalid UUID: ${entityId}`);
    }

    // Step 2: VALIDATE DATABASE PERSISTENCE WITH PROPER FIELDS
    console.log('ğŸ” Step 2: Validating database entity integrity...');
    const dbReadResult = await runJtagCommand(`data/read --collection=${config.collection} --id=${entityId}`);
    const dbEntity = dbReadResult.data;

    // DEEP VALIDATION of entity structure
    const hasValidId = dbEntity?.id && typeof dbEntity.id === 'string';
    const hasValidCreatedAt = dbEntity?.createdAt && !isNaN(Date.parse(dbEntity.createdAt));
    const hasValidVersion = typeof dbEntity?.version === 'number' && dbEntity.version > 0;

    // Collection-specific validation
    let collectionValid = false;
    if (config.collection === 'ChatMessage') {
      const hasValidTimestamp = dbEntity?.timestamp && !isNaN(Date.parse(dbEntity.timestamp));
      const hasValidContent = dbEntity?.content && typeof dbEntity.content.text === 'string';
      collectionValid = hasValidTimestamp && hasValidContent;
    } else if (config.collection === 'User') {
      const hasValidDisplayName = dbEntity?.displayName && typeof dbEntity.displayName === 'string';
      collectionValid = hasValidDisplayName;
    } else {
      collectionValid = true; // Room or other
    }

    console.log(`   DB Entity ID: ${dbEntity?.id} (valid: ${hasValidId})`);
    console.log(`   DB CreatedAt: ${dbEntity?.createdAt} (valid: ${hasValidCreatedAt})`);
    console.log(`   DB Version: ${dbEntity?.version} (valid: ${hasValidVersion})`);
    console.log(`   Collection-specific fields: ${collectionValid ? 'VALID' : 'INVALID'}`);

    const dbIntegrityValid = hasValidId && hasValidCreatedAt && hasValidVersion && collectionValid;
    results.push({
      step: `${config.collection} Database Integrity`,
      success: dbIntegrityValid,
      details: { hasValidId, hasValidCreatedAt, hasValidVersion, collectionValid }
    });

    // Step 3: VALIDATE WIDGET HTML INTEGRATION
    console.log('ğŸ” Step 3: Validating widget HTML integration...');
    const widgetState = await runJtagCommand(`debug/widget-state --widgetSelector="${config.widget}" --extractRowData=true`);
    const rowData = widgetState.commandResult?.state?.rowData || [];

    // Look for our test entity in widget data
    const entityFoundInWidget = rowData.some((row: any) =>
      JSON.stringify(row).includes(entityId) ||
      (config.collection === 'ChatMessage' && JSON.stringify(row).includes("TEST ENTITY VALIDATION MESSAGE")) ||
      (config.collection === 'User' && JSON.stringify(row).includes("Test Entity Validation User"))
    );

    console.log(`   Widget rows found: ${rowData.length}`);
    console.log(`   Entity found in widget: ${entityFoundInWidget ? 'YES' : 'NO'}`);

    results.push({
      step: `${config.widget} HTML Integration`,
      success: entityFoundInWidget,
      details: { rowCount: rowData.length, entityFoundInWidget }
    });

    // Step 4: VALIDATE HTML ATTRIBUTES INTEGRITY
    console.log('ğŸ” Step 4: Validating HTML attributes integrity...');
    const htmlCheckResult = await runJtagCommand(`exec --code='{"type": "inline", "language": "javascript", "source": "const widget = document.querySelector(\\"continuum-widget\\")?.shadowRoot?.querySelector(\\"sidebar-widget\\")?.shadowRoot?.querySelector(\\"${config.widget}\\"); if (widget) { const items = widget.shadowRoot.querySelectorAll(\\".${config.collection.toLowerCase()}-item, .message-row, .user-item, .room-item\\"); const invalidIds = Array.from(items).filter(item => { const entityId = item.getAttribute(\\"data-entity-id\\"); return !entityId || entityId === \\"unknown\\" || entityId === \\"null\\"; }); return { totalItems: items.length, invalidItems: invalidIds.length, sampleId: items[0]?.getAttribute(\\"data-entity-id\\") }; } return { error: \\"Widget not found\\" };"}'`);

    const htmlCheck = htmlCheckResult.commandResult?.result;
    const hasValidHtmlIds = htmlCheck && htmlCheck.invalidItems === 0;

    console.log(`   Total HTML items: ${htmlCheck?.totalItems || 'N/A'}`);
    console.log(`   Invalid data-entity-id attributes: ${htmlCheck?.invalidItems || 'N/A'}`);
    console.log(`   Sample entity ID: ${htmlCheck?.sampleId || 'N/A'}`);

    results.push({
      step: `${config.widget} HTML Attributes Integrity`,
      success: Boolean(hasValidHtmlIds),
      details: htmlCheck
    });

    // Overall assessment - ALL STEPS MUST PASS
    const allStepsValid = results.slice(-4).every(result => result.success);
    console.log(`\nğŸ¯ ${config.collection} â†” ${config.widget} RESULT: ${allStepsValid ? 'âœ… PASS' : 'âŒ FAIL'}`);

    if (allStepsValid) {
      console.log('âœ… Entity creation validation: PASSED');
      console.log('âœ… Database integrity: PASSED');
      console.log('âœ… Widget integration: PASSED');
      console.log('âœ… HTML attributes: PASSED');
    } else {
      console.log('âŒ Entity validation has issues:');
      const recentResults = results.slice(-4);
      recentResults.forEach(result => {
        const status = result.success ? 'âœ…' : 'âŒ';
        console.log(`   ${status} ${result.step}`);
      });
    }

  } catch (error) {
    console.error(`âŒ ${config.collection}-${config.widget} test failed:`, error instanceof Error ? error.message : String(error));
    results.push({
      step: `${config.collection}-${config.widget} Test`,
      success: false,
      error: error instanceof Error ? error.message : String(error)
    });
  }
}

async function runModularTests(): Promise<void> {
  // Test configurations for all three Collection-Widget pairs
  // Updated to test ENTITY CREATION instead of just updates
  const testConfigs: TestConfig[] = [
    {
      collection: 'ChatMessage',
      widget: 'chat-widget',
      testId: '5e71a0c8-0303-4eb8-a478-3a121248', // roomId for ChatMessage
      updateData: { content: { text: 'ENTITY VALIDATION TEST MESSAGE', attachments: [] } },
      verifyField: 'content',
      expectedValue: 'TEST ENTITY VALIDATION MESSAGE'
    },
    {
      collection: 'User',
      widget: 'user-list-widget',
      testId: 'user-test-id', // Will be overridden by entity creation
      updateData: { displayName: 'ENTITY VALIDATION TEST USER' },
      verifyField: 'displayName',
      expectedValue: 'Test Entity Validation User'
    },
    {
      collection: 'Room',
      widget: 'room-list-widget',
      testId: 'room-test-id', // Will be overridden by entity creation
      updateData: { name: 'ENTITY VALIDATION TEST ROOM', description: 'Test room for validation' },
      verifyField: 'name',
      expectedValue: 'ENTITY VALIDATION TEST ROOM'
    }
  ];

  // Run all tests
  for (const config of testConfigs) {
    await testCRUDWidgetSync(config);
  }

  // Summary
  console.log('\nğŸ‰ MODULAR CRUD-WIDGET SYNC TEST SUMMARY');
  console.log('========================================');

  let passCount = 0;
  let failCount = 0;

  results.forEach(result => {
    const status = result.success ? 'âœ… PASS' : 'âŒ FAIL';
    console.log(`   ${status} ${result.step}`);
    if (result.success) passCount++;
    else failCount++;

    if (result.error) {
      console.log(`      Error: ${result.error}`);
    }
  });

  console.log(`\nğŸ“Š Results: ${passCount} passed, ${failCount} failed`);

  const overallSuccess = failCount === 0;
  console.log(`\nğŸ OVERALL: ${overallSuccess ? 'âœ… ALL TESTS PASSED' : 'âŒ SOME TESTS FAILED'}`);

  if (overallSuccess) {
    console.log('ğŸ¯ React-like CRUD reactivity is working across all widgets');
    console.log('ğŸ¯ Database and HTML synchronization is consistent');
    console.log('ğŸ¯ No timeouts needed - promises resolve after events');
  } else {
    console.log('ğŸ“ Some Collection-Widget pairs need fixes');
    console.log('ğŸ“ Check event emission and widget subscriptions');
  }

  // Exit with proper code
  process.exit(overallSuccess ? 0 : 1);
}

// Run the modular tests
runModularTests();