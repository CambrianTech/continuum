/**
 * Academy Command Types - Co-Evolutionary Capability System
 * =========================================================
 * 
 * Type definitions for academy commands that implement co-evolutionary
 * capability tracking within the JTAG fabric. Uses existing daemon
 * infrastructure for storage and processing.
 * 
 * Architecture:
 * - ArtifactsDaemon: File storage for capability manifolds, network data
 * - DatabaseDaemon: MySQL storage for persona layers, evolution tracking
 * - Modular commands: track-usage/, evolve-capability/, analyze-impact/
 */

import { CommandParams, CommandResult } from '../../shared/CommandTypes';

// ========================
// Base Academy Types
// ========================

export abstract class AcademyParams<T extends Record<string, any> = {}> extends CommandParams {
  academyId: string;
  
  constructor(data: Partial<AcademyParams<T> & T> = {}) {
    super();
    Object.assign(this, { 
      academyId: 'default-academy',
      ...data 
    });
  }
}

export abstract class AcademyResult<T extends Record<string, any> = {}> extends CommandResult {
  academyId: string;
  
  constructor(data: Partial<AcademyResult<T> & T> = {}) {
    super();
    Object.assign(this, data);
  }
}

// ========================
// Capability Network Types
// ========================

export interface CapabilityNode {
  id: string;
  name: string;
  description: string;
  
  // Network properties (emergent from usage)
  impactScore: number;           // Citation-style impact
  usageFrequency: number;        // How often used
  performanceCorrelation: number; // Average performance when used
  networkCentrality: number;     // Position in capability network
  
  // Relationships (discovered from co-occurrence)
  incomingReferences: string[];  // Capabilities that reference this
  outgoingReferences: string[];  // Capabilities this references
  coOccurrences: Record<string, number>; // Frequently used together
  
  // Evolution tracking
  emergenceTimestamp: number;
  lastUsedTimestamp: number;
  stabilityScore: number;        // How stable this capability is
  evolutionVelocity: number;     // How fast it's changing
  
  // Storage metadata
  artifactPath?: string;         // Path in ArtifactsDaemon if stored
  databaseId?: string;          // ID in DatabaseDaemon if persisted
}

export interface CapabilityUsage {
  capabilityId: string;
  interactionId: string;
  timestamp: number;
  context: InteractionContext;
  performance: PerformanceMetrics;
  
  // Co-occurrence data
  coUsedCapabilities: string[];
  sequencePosition: number;      // Position in capability sequence
  
  // Context categorization (emergent)
  contextClusters: string[];     // Which context clusters this belongs to
  performanceImpact: number;     // How much this contributed to success
}

export interface InteractionContext {
  type: 'chat' | 'command' | 'automation' | 'problem_solving';
  domain: string[];              // e.g., ['typescript', 'debugging', 'web_development']
  complexity: number;            // 0-1 complexity score
  participants: string[];        // Human/AI participants
  tools: string[];               // Tools used during interaction
  
  // Raw context features (for ML processing)
  rawFeatures: Record<string, any>;
}

export interface PerformanceMetrics {
  technicalSuccess: number;      // 0-1 did it work correctly
  userSatisfaction: number;      // 0-1 human feedback
  efficiency: number;            // 0-1 speed/resource usage
  collaboration: number;         // 0-1 how well it worked with others
  innovation: number;            // 0-1 novel solution quality
  
  // Detailed metrics
  responseLatency: number;       // milliseconds
  errorRate: number;            // 0-1 error frequency
  followUpRequired: boolean;     // Did user need clarification
  
  // Composite score
  overallScore: number;         // Weighted combination of above
}

// ========================
// Persona Genome Types
// ========================

export interface PersonaGenome {
  id: string;
  personaId: string;
  version: string;
  
  // Genome composition
  baseModel: string;            // e.g., 'claude-3.5-sonnet'
  genomicLayers: GenomicLayer[];
  
  // Capability vector (dynamic size)
  capabilityVector: number[];   // Current capability strengths
  vectorDimensions: number;     // Size of capability vector
  
  // Performance profile
  averagePerformance: PerformanceMetrics;
  domainSpecificPerformance: Record<string, PerformanceMetrics>;
  
  // Evolution tracking
  parentGenomes: string[];      // Genomes this evolved from
  evolutionHistory: GenomeEvolution[];
  
  // Storage
  createdAt: number;
  updatedAt: number;
  artifactPath: string;         // Stored in ArtifactsDaemon
  databaseRecordId: string;     // Stored in DatabaseDaemon
}

export interface GenomicLayer {
  id: string;
  type: 'foundation' | 'lora' | 'memory' | 'specialization' | 'communication';
  name: string;
  version: string;
  
  // Layer data
  capabilities: string[];       // Capabilities this layer provides
  weights?: ArrayBuffer;        // Neural network weights (if applicable)
  configuration: Record<string, any>; // Layer-specific config
  
  // Performance data
  performanceImpact: Record<string, number>; // Impact on different capabilities
  activationPatterns: Record<string, number>; // When this layer is most active
  
  // Provenance
  createdBy: string;           // Node/user that created this
  trainingData: string[];      // Training data references
  parentLayers: string[];      // Layers this evolved from
  
  // Storage
  artifactPath: string;        // File path for layer data
  size: number;               // Size in bytes
  checksum: string;           // Data integrity check
}

export interface GenomeEvolution {
  id: string;
  timestamp: number;
  trigger: 'performance_gap' | 'capability_request' | 'automatic_optimization' | 'manual_evolution';
  
  // Evolution details
  addedLayers: GenomicLayer[];
  removedLayers: string[];     // IDs of removed layers
  modifiedLayers: Partial<GenomicLayer>[];
  
  // Performance impact
  beforePerformance: PerformanceMetrics;
  afterPerformance: PerformanceMetrics;
  improvementScore: number;    // -1 to 1 improvement
  
  // Context
  evolutionReason: string;
  contextData: InteractionContext;
  
  // Validation
  validated: boolean;
  validationResults?: ValidationResults;
}

// ========================
// Dynamic Structure Types
// ========================

export interface CapabilityManifold {
  id: string;
  version: number;
  
  // Current structure
  dimensions: number;
  topology: 'euclidean' | 'hyperbolic' | 'spherical' | 'graph' | 'hybrid';
  
  // Capability organization
  capabilities: Map<string, CapabilityNode>;
  clusters: CapabilityCluster[];
  
  // Network structure
  adjacencyMatrix: number[][];  // Capability relationships
  communityStructure: Community[];
  
  // Manifold properties
  intrinsicDimensionality: number;
  informationEntropy: number;
  networkResilience: number;
  
  // Evolution tracking
  evolutionHistory: ManifoldEvolution[];
  lastReorganization: number;
  stabilityMetrics: StabilityProfile;
  
  // Storage
  artifactPath: string;        // Serialized manifold data
  checkpointPaths: string[];   // Historical snapshots
}

export interface CapabilityCluster {
  id: string;
  name: string;
  description: string;
  
  // Cluster members
  capabilities: string[];      // Capability IDs in this cluster
  centroid: number[];         // Center point in capability space
  
  // Cluster properties
  coherence: number;          // How tightly clustered
  separation: number;         // How distinct from other clusters
  stability: number;          // How stable over time
  
  // Semantic information
  dominantThemes: string[];   // Main topics in this cluster
  performanceCharacteristics: PerformanceProfile;
  
  // Evolution
  emergenceTimestamp: number;
  parentClusters: string[];   // Clusters this evolved from
  childClusters: string[];    // Clusters that evolved from this
}

export interface Community {
  id: string;
  members: string[];          // Capability IDs
  modularity: number;         // Community strength
  bridgeNodes: string[];      // Capabilities that connect to other communities
  
  // Community properties
  averagePathLength: number;
  clusteringCoefficient: number;
  centralNodes: string[];     // Most important nodes in community
  
  // Semantic characteristics
  communityTheme: string;
  dominantCapabilities: string[];
  performanceProfile: PerformanceProfile;
}

// ========================
// Analysis Types
// ========================

export interface ImpactAnalysis {
  capabilityId: string;
  
  // Impact metrics
  directImpact: number;        // Direct usage impact
  networkImpact: number;       // Network position impact
  temporalImpact: number;      // Recent vs historical impact
  qualityImpact: number;       // Performance correlation impact
  
  // Rankings
  overallRank: number;
  categoryRanks: Record<string, number>;
  
  // Trends
  impactTrend: 'rising' | 'stable' | 'declining';
  trendVelocity: number;
  
  // Network analysis
  pageRank: number;
  betweennessCentrality: number;
  eigenvectorCentrality: number;
  
  // Recommendations
  recommendations: string[];
  potentialEvolutions: string[];
}

// ========================
// Storage Integration Types
// ========================

export interface ArtifactStorageInfo {
  path: string;
  size: number;
  checksum: string;
  lastModified: number;
  compressionType?: 'gzip' | 'lz4' | 'none';
  encryptionType?: 'aes256' | 'none';
}

export interface DatabaseStorageInfo {
  table: string;
  recordId: string;
  indexes: string[];           // Database indexes for this record
  foreignKeys: Record<string, string>; // Relationships to other records
  lastUpdated: number;
  metadata: Record<string, any>;
}

// ========================
// Command-Specific Types
// ========================

export interface UsageTrackingData {
  interactionId: string;
  capabilities: CapabilityUsage[];
  context: InteractionContext;
  performance: PerformanceMetrics;
  timestamp: number;
  
  // Storage hints
  persistToDatabase: boolean;
  artifactCheckpoint: boolean;
}

export interface EvolutionRequest {
  personaId: string;
  trigger: GenomeEvolution['trigger'];
  targetCapabilities?: string[];
  performanceGoals?: Partial<PerformanceMetrics>;
  constraints?: EvolutionConstraints;
  
  // Context for evolution
  currentContext: InteractionContext;
  recentPerformance: PerformanceMetrics[];
}

export interface EvolutionConstraints {
  maxLayerAdditions: number;
  maxLayerRemovals: number;
  maxSizeIncrease: number;      // Bytes
  minPerformanceImprovement: number;
  preserveCapabilities: string[]; // Must not lose these capabilities
  
  // Resource constraints
  computeLimit: number;         // Max compute for evolution process
  storageLimit: number;         // Max storage for new genome
  timeLimit: number;           // Max time for evolution (ms)
}

// ========================
// Helper Types
// ========================

export interface ValidationResults {
  passed: boolean;
  performanceTests: TestResult[];
  capabilityTests: TestResult[];
  regressionTests: TestResult[];
  
  overallScore: number;
  issues: ValidationIssue[];
  recommendations: string[];
}

export interface TestResult {
  testName: string;
  passed: boolean;
  score: number;
  details: Record<string, any>;
  executionTime: number;
}

export interface ValidationIssue {
  severity: 'error' | 'warning' | 'info';
  category: string;
  message: string;
  affectedCapabilities: string[];
  suggestedFix?: string;
}

export interface StabilityProfile {
  structuralStability: number;  // How stable the structure is
  performanceStability: number; // How stable performance is
  evolutionRate: number;        // How fast things are changing
  
  stabilityTrend: 'improving' | 'stable' | 'declining';
  riskFactors: string[];
  stabilityProjection: number;  // Projected stability in future
}

export interface PerformanceProfile {
  averageMetrics: PerformanceMetrics;
  variance: Record<keyof PerformanceMetrics, number>;
  trends: Record<keyof PerformanceMetrics, 'improving' | 'stable' | 'declining'>;
  
  // Context-specific performance
  contextualPerformance: Record<string, PerformanceMetrics>;
  
  // Benchmarking
  benchmarkScores: Record<string, number>;
  competitivePosition: number; // Relative to other personas/capabilities
}

// ========================
// Export consolidated types
// ========================

export type AcademyEntityType = 
  | CapabilityNode 
  | PersonaGenome 
  | GenomicLayer 
  | CapabilityManifold 
  | CapabilityCluster;

export type AcademyAnalysisType = 
  | ImpactAnalysis 
  | PerformanceProfile 
  | StabilityProfile 
  | ValidationResults;

export type AcademyStorageType = 
  | ArtifactStorageInfo 
  | DatabaseStorageInfo;