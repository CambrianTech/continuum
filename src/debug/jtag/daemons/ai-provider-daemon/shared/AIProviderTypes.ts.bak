/**
 * AI Provider Types - Unified Interface for All AI Services
 * =========================================================
 * 
 * Provides unified types for integrating with any AI provider (OpenAI, Anthropic,
 * Google, Meta, Mistral, local models, etc.) through pluggable adapters.
 * 
 * Architecture:
 * - Provider-agnostic interfaces for all AI operations
 * - Pluggable adapter system for different AI services
 * - Automatic provider selection based on capabilities and constraints
 * - Integration with Academy training system for capability tracking
 * - Cost management and usage monitoring across providers
 */

import { CommandParams, CommandResult } from '../../../shared/JTAGTypes';

// ========================
// Core Provider Types
// ========================

export abstract class AIProviderParams<T extends Record<string, any> = {}> extends CommandParams {
  // Provider selection
  preferredProvider?: string;            // Specific provider to use
  providerStrategy?: ProviderSelectionStrategy;
  
  // Request metadata
  requestId!: string;
  trainingContext?: TrainingContext;
  
  constructor(data: Partial<AIProviderParams<T> & T> = {}) {
    super();
    Object.assign(this, {
      requestId: `ai_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
      ...data
    });
  }
}

export abstract class AIProviderResult<T extends Record<string, any> = {}> extends CommandResult {
  // Provider information
  providerId!: string;
  providerName!: string;
  modelUsed!: string;
  
  // Usage tracking
  usage!: UsageMetrics;
  cost?: number;                         // Cost in USD if available
  
  // Response metadata
  responseTime!: number;                  // milliseconds
  requestId!: string;
  
  constructor(data: Partial<AIProviderResult<T> & T> = {}) {
    super();
    Object.assign(this, {
      providerId: '',
      providerName: '',
      modelUsed: '',
      usage: { tokens: 0, cost: 0 },
      responseTime: 0,
      requestId: `ai_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
      ...data
    });
  }
}

// ========================
// Provider Capabilities
// ========================

export interface ProviderCapabilities {
  // Core capabilities
  textGeneration: boolean;
  imageGeneration: boolean;
  imageAnalysis: boolean;
  audioGeneration: boolean;
  audioAnalysis: boolean;
  videoAnalysis: boolean;
  codeGeneration: boolean;
  
  // Advanced capabilities
  functionCalling: boolean;              // Can call functions/tools
  streamingResponse: boolean;            // Supports streaming
  multimodalInput: boolean;              // Can handle mixed inputs
  fineTuning: boolean;                   // Supports fine-tuning
  embedding: boolean;                    // Can generate embeddings
  
  // Model characteristics
  contextWindow: number;                 // Maximum context length
  outputLength: number;                  // Maximum output length
  supportedLanguages: string[];          // Programming/natural languages
  
  // Quality characteristics
  reasoningCapability: 'basic' | 'intermediate' | 'advanced' | 'expert';
  creativityLevel: 'low' | 'medium' | 'high' | 'very_high';
  factualAccuracy: 'low' | 'medium' | 'high' | 'very_high';
  codingAbility: 'basic' | 'intermediate' | 'advanced' | 'expert';
  
  // Performance characteristics
  averageLatency: number;                // milliseconds
  costPerToken: number;                  // USD per token
  rateLimit: RateLimit;
  
  // Privacy and deployment
  dataRetention: 'none' | 'temporary' | 'permanent';
  deploymentType: 'cloud' | 'local' | 'hybrid';
  privacyLevel: 'public' | 'private' | 'enterprise';
}

export interface RateLimit {
  requestsPerMinute: number;
  tokensPerMinute: number;
  requestsPerDay?: number;
  tokensPerDay?: number;
  concurrentRequests: number;
}

// ========================
// Provider Adapter Interface
// ========================

export interface AIProviderAdapter {
  // Provider identification
  readonly providerId: string;
  readonly providerName: string;
  readonly version: string;
  
  // Capabilities
  readonly capabilities: ProviderCapabilities;
  readonly availableModels: AIModel[];
  
  // Configuration
  configuration: ProviderConfiguration;
  
  // Core operations
  generateText(request: TextGenerationRequest): Promise<TextGenerationResponse>;
  generateImage?(request: ImageGenerationRequest): Promise<ImageGenerationResponse>;
  analyzeMedia?(request: MediaAnalysisRequest): Promise<MediaAnalysisResponse>;
  embedContent?(request: EmbeddingRequest): Promise<EmbeddingResponse>;
  
  // Streaming operations
  streamText?(request: TextGenerationRequest): AsyncIterable<TextStreamChunk>;
  
  // Model management
  getModels(): Promise<AIModel[]>;
  getModelInfo(modelId: string): Promise<ModelInfo>;
  
  // Health and monitoring
  healthCheck(): Promise<HealthStatus>;
  getUsage(): Promise<UsageMetrics>;
  
  // Provider-specific features
  getProviderSpecificFeatures?(): Promise<Record<string, any>>;
  
  // Lifecycle
  initialize(): Promise<void>;
  shutdown(): Promise<void>;
}

export interface AIModel {
  id: string;
  name: string;
  description: string;
  
  // Model characteristics
  type: 'text' | 'image' | 'multimodal' | 'embedding' | 'audio' | 'video';
  capabilities: string[];
  
  // Technical specs
  contextWindow: number;
  maxOutputTokens: number;
  parametersCount?: number;               // Model size
  
  // Performance
  averageLatency: number;                // ms
  costPerInputToken: number;             // USD
  costPerOutputToken: number;            // USD
  
  // Quality metrics
  qualityRating: number;                 // 0-1
  specializations: string[];             // What it's best at
  
  // Availability
  available: boolean;
  deprecated: boolean;
  replacementModel?: string;
  
  // Constraints
  rateLimit: RateLimit;
  privacyLevel: 'public' | 'private' | 'enterprise';
}

export interface ProviderConfiguration {
  // Authentication
  apiKey?: string;
  apiEndpoint?: string;
  organizationId?: string;
  
  // Request configuration
  timeout: number;                       // milliseconds
  retryAttempts: number;
  retryDelay: number;                    // milliseconds
  
  // Rate limiting
  respectRateLimits: boolean;
  customRateLimit?: RateLimit;
  
  // Quality settings
  defaultModel?: string;
  defaultQuality: 'fast' | 'balanced' | 'quality';
  
  // Cost management
  maxCostPerRequest?: number;            // USD
  dailyBudget?: number;                  // USD
  
  // Privacy settings
  dataRetentionPolicy: 'minimal' | 'standard' | 'extended';
  logRequests: boolean;
  anonymizeRequests: boolean;
}

// ========================
// Request/Response Types
// ========================

export interface TextGenerationRequest {
  // Input
  messages: ChatMessage[];
  systemPrompt?: string;
  
  // Model configuration
  model?: string;
  temperature?: number;                  // 0-2
  maxTokens?: number;
  topP?: number;                         // 0-1
  frequencyPenalty?: number;             // -2 to 2
  presencePenalty?: number;              // -2 to 2
  
  // Advanced features
  tools?: ToolDefinition[];              // Function calling
  toolChoice?: 'auto' | 'none' | ToolChoice;
  responseFormat?: 'text' | 'json' | ResponseFormatSchema;
  
  // Streaming
  stream?: boolean;
  
  // Context
  personaContext?: PersonaContext;
  trainingContext?: TrainingContext;
  
  // Quality/Performance tradeoffs
  prioritize: 'speed' | 'quality' | 'cost';
  maxWaitTime?: number;                  // milliseconds
}

export interface TextGenerationResponse {
  // Generated content
  text: string;
  finishReason: 'stop' | 'length' | 'tool_calls' | 'content_filter';
  
  // Tool usage
  toolCalls?: ToolCall[];
  
  // Metadata
  model: string;
  usage: UsageMetrics;
  responseTime: number;                  // milliseconds
  
  // Quality metrics
  confidence?: number;                   // 0-1 if available
  alternatives?: string[];               // Alternative responses
  
  // Provider-specific
  providerMetadata?: Record<string, any>;
}

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string | MessageContent[];   // Text or multimodal content
  name?: string;                         // Participant name
  toolCallId?: string;                   // For tool responses
  
  // Academy-specific metadata
  personaId?: string;
  learningContext?: string;
  capabilitiesUsed?: string[];
  timestamp?: number;
}

export interface MessageContent {
  type: 'text' | 'image' | 'audio' | 'video' | 'file';
  content: string;                       // Text content or data URL
  
  // Media metadata
  mimeType?: string;
  fileSize?: number;
  description?: string;                  // Alt text for images
}

export interface ImageGenerationRequest {
  // Prompt
  prompt: string;
  negativePrompt?: string;
  
  // Image configuration
  model?: string;
  size?: string;                         // '1024x1024', '512x512', etc.
  quality?: 'standard' | 'hd';
  style?: 'vivid' | 'natural' | string;
  
  // Generation parameters
  n?: number;                            // Number of images
  seed?: number;                         // For reproducibility
  steps?: number;                        // Diffusion steps
  guidance?: number;                     // Guidance scale
  
  // Context
  trainingContext?: TrainingContext;
  educationalPurpose?: string;
  
  // Output format
  responseFormat?: 'url' | 'b64_json';
}

export interface ImageGenerationResponse {
  images: GeneratedImage[];
  
  // Metadata
  model: string;
  usage: UsageMetrics;
  responseTime: number;
  
  // Generation info
  revisedPrompt?: string;                // Revised by safety systems
  safetyRating?: SafetyRating;
}

export interface GeneratedImage {
  url?: string;                          // Image URL
  b64Json?: string;                      // Base64 encoded image
  revisedPrompt?: string;                // What was actually generated
  
  // Metadata
  size: string;                          // '1024x1024'
  seed?: number;                         // Seed used
  
  // Quality assessment
  aestheticScore?: number;               // 0-1 aesthetic quality
  relevanceScore?: number;               // 0-1 relevance to prompt
}

export interface MediaAnalysisRequest {
  // Media to analyze
  mediaUrl?: string;
  mediaData?: string;                    // Base64 encoded
  mediaType: 'image' | 'audio' | 'video';
  
  // Analysis configuration
  model?: string;
  analysisTypes: AnalysisType[];
  
  // Context
  educationalContext?: EducationalContext;
  expectedContent?: string;              // What we expect to see
  
  // Output preferences
  detailLevel: 'basic' | 'detailed' | 'comprehensive';
  includeConfidence: boolean;
}

export interface MediaAnalysisResponse {
  // Analysis results
  analysis: AnalysisResult[];
  
  // Overall assessment
  overallConfidence: number;             // 0-1
  summary: string;
  
  // Educational analysis
  educationalValue?: number;             // 0-1
  skillsRequired?: string[];
  conceptsPresent?: string[];
  
  // Metadata
  model: string;
  usage: UsageMetrics;
  responseTime: number;
}

// ========================
// Provider Selection
// ========================

export type ProviderSelectionStrategy = 
  | 'cheapest'
  | 'fastest' 
  | 'highest_quality'
  | 'best_for_task'
  | 'local_preferred'
  | 'custom';

export interface ProviderSelectionCriteria {
  // Required capabilities
  requiredCapabilities: string[];
  
  // Quality requirements
  minQualityRating?: number;             // 0-1
  prioritize: 'speed' | 'quality' | 'cost' | 'privacy';
  
  // Constraints
  maxCostPerRequest?: number;            // USD
  maxLatency?: number;                   // milliseconds
  privacyLevel?: 'public' | 'private' | 'local';
  
  // Preferences
  preferredProviders?: string[];         // Ordered preference
  excludedProviders?: string[];
  
  // Context
  taskType?: string;                     // 'coding', 'creative', 'analytical'
  domainSpecialization?: string[];       // Domain expertise needed
  
  // Fallback strategy
  fallbackStrategy: 'next_best' | 'fail' | 'downgrade_quality';
}

export interface ProviderSelection {
  selectedProvider: string;
  selectedModel: string;
  selectionReason: string;
  
  // Expected performance
  expectedLatency: number;               // milliseconds
  expectedCost: number;                  // USD
  expectedQuality: number;               // 0-1
  
  // Alternatives
  alternativeProviders: AlternativeProvider[];
  
  // Selection metadata
  selectionTime: number;                 // milliseconds to select
  criteriaUsed: ProviderSelectionCriteria;
}

export interface AlternativeProvider {
  providerId: string;
  modelId: string;
  score: number;                         // 0-1 how well it matches criteria
  reason: string;                        // Why it wasn't selected
  
  // Characteristics
  estimatedLatency: number;
  estimatedCost: number;
  estimatedQuality: number;
}

// ========================
// Usage and Monitoring
// ========================

export interface UsageMetrics {
  // Token usage
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  
  // Request info
  requestCount: number;
  successfulRequests: number;
  failedRequests: number;
  
  // Cost tracking
  estimatedCost?: number;                // USD
  
  // Performance
  averageLatency: number;                // milliseconds
  minLatency: number;
  maxLatency: number;
  
  // Time period
  periodStart: number;                   // timestamp
  periodEnd: number;                     // timestamp
}

export interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  
  // Service health
  apiAvailable: boolean;
  responseTime: number;                  // milliseconds
  errorRate: number;                     // 0-1
  
  // Capacity
  rateLimitStatus: RateLimitStatus;
  queueDepth?: number;                   // Pending requests
  
  // Issues
  currentIssues: HealthIssue[];
  lastChecked: number;                   // timestamp
}

export interface RateLimitStatus {
  requestsRemaining: number;
  tokensRemaining: number;
  resetTime: number;                     // timestamp
  
  // Current usage
  currentRequestsPerMinute: number;
  currentTokensPerMinute: number;
}

export interface HealthIssue {
  severity: 'low' | 'medium' | 'high' | 'critical';
  type: 'latency' | 'errors' | 'rate_limit' | 'cost' | 'availability';
  description: string;
  
  // Issue details
  firstObserved: number;                 // timestamp
  affectedRequests: number;
  suggestedAction?: string;
  
  // Impact
  impactOnPerformance: number;           // 0-1
  impactOnCost: number;                  // 0-1
}

// ========================
// Training Integration
// ========================

export interface TrainingContext {
  // Academy session info
  sessionId: string;
  personaId: string;
  learningObjectives: string[];
  
  // Training phase
  trainingPhase: 'introduction' | 'exploration' | 'practice' | 'assessment';
  difficultyLevel: number;               // 0-1
  
  // Performance tracking
  trackCapabilities: boolean;
  trackPerformance: boolean;
  contributeToLearning: boolean;
  
  // Context
  currentTopic: string;
  recentInteractions: string[];          // Recent conversation context
  performanceGoals: PerformanceGoal[];
}

export interface PersonaContext {
  personaId: string;
  personaName: string;
  
  // Persona characteristics
  personality: PersonalityTraits;
  capabilities: string[];
  specializations: string[];
  
  // Current state
  currentKnowledge: string[];
  learningGoals: string[];
  conversationStyle: ConversationStyle;
  
  // Adaptation
  adaptationLevel: number;               // 0-1 how much to adapt
  personalizationEnabled: boolean;
}

export interface PerformanceGoal {
  metric: 'accuracy' | 'helpfulness' | 'clarity' | 'efficiency' | 'creativity';
  targetValue: number;                   // 0-1
  currentValue?: number;                 // Current performance
  importance: number;                    // 0-1 how important this goal is
}

// ========================
// Supporting Types
// ========================

export interface ToolDefinition {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: Record<string, any>;     // JSON schema
  };
}

export interface ToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string;                   // JSON string
  };
}

export interface ToolChoice {
  type: 'function';
  function: {
    name: string;
  };
}

export interface ResponseFormatSchema {
  type: 'json_object';
  schema?: Record<string, any>;          // JSON schema
}

export type AnalysisType = 
  | 'object_detection'
  | 'scene_understanding' 
  | 'text_extraction'
  | 'face_recognition'
  | 'activity_recognition'
  | 'educational_analysis'
  | 'accessibility_analysis';

export interface AnalysisResult {
  type: AnalysisType;
  confidence: number;                    // 0-1
  results: Record<string, any>;         // Type-specific results
  description: string;
  
  // Bounding boxes for visual analysis
  boundingBoxes?: BoundingBox[];
  
  // Educational insights
  educationalInsights?: EducationalInsight[];
}

export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
  confidence: number;
  label: string;
}

export interface EducationalInsight {
  insight: string;
  confidence: number;                    // 0-1
  relevance: number;                     // 0-1 relevance to learning objectives
  actionable: boolean;                   // Can this insight be acted upon
  
  // Learning connections
  relatedConcepts: string[];
  requiredSkills: string[];
  learningOpportunities: string[];
}

export interface SafetyRating {
  overall: 'safe' | 'questionable' | 'unsafe';
  categories: SafetyCategory[];
  confidence: number;                    // 0-1
  
  // Actions taken
  contentFiltered: boolean;
  promptRevised: boolean;
  warningsIssued: string[];
}

export interface SafetyCategory {
  category: string;                      // 'violence', 'adult', 'hate', etc.
  severity: 'low' | 'medium' | 'high';
  confidence: number;                    // 0-1
}

export interface TextStreamChunk {
  delta: string;                         // New text content
  finishReason?: 'stop' | 'length' | 'tool_calls';
  
  // Tool calls (for function calling)
  toolCalls?: Partial<ToolCall>[];
  
  // Metadata
  index: number;                         // Chunk sequence number
  model?: string;
  usage?: Partial<UsageMetrics>;         // Updated usage stats
  
  // Quality indicators
  confidence?: number;                   // 0-1 confidence in this chunk
}

// ========================
// Missing Type Definitions  
// ========================

export interface EmbeddingRequest {
  text: string;
  model?: string;
}

export interface EmbeddingResponse {
  embedding: number[];
  model: string;
  usage: UsageMetrics;
}

export interface ModelInfo {
  id: string;
  name: string;
  description: string;
  capabilities: string[];
}

export interface PersonalityTraits {
  creativity: number;
  formality: number;
  empathy: number;
}

export interface ConversationStyle {
  tone: string;
  verbosity: string;
  technical_level: string;
}

export interface EducationalContext {
  level: string;
  subject: string;
  goals: string[];
}

// Export types for easy importing
export type AIRequest = 
  | TextGenerationRequest 
  | ImageGenerationRequest 
  | MediaAnalysisRequest 
  | EmbeddingRequest;

export type AIResponse = 
  | TextGenerationResponse 
  | ImageGenerationResponse 
  | MediaAnalysisResponse 
  | EmbeddingResponse;

export type ProviderData = 
  | AIProviderAdapter 
  | AIModel 
  | ProviderConfiguration 
  | ProviderCapabilities;

export type MonitoringData = 
  | UsageMetrics 
  | HealthStatus 
  | PerformanceGoal 
  | TrainingContext;