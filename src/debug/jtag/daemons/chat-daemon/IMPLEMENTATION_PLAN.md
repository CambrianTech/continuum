# Chat Daemon - Detailed Implementation Plan

## ğŸ›ï¸ **CLEAN ARCHITECTURE PRINCIPLES**

### **Dependency Inversion**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Chat Domain   â”‚    â”‚  JTAG Commands  â”‚
â”‚   (Pure Logic)  â”‚    â”‚  (Interface)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                       â–²
         â”‚                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Storage Port   â”‚    â”‚ Transport Port  â”‚
â”‚  (Interface)    â”‚    â”‚  (Interface)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                       â–²
         â”‚                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DataDaemon Impl â”‚    â”‚ JTAG Router Implâ”‚
â”‚  (Adapter)      â”‚    â”‚   (Adapter)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Separation of Concerns**
- **Domain Layer**: Chat logic, participant management, response rules
- **Application Layer**: Use cases, event orchestration
- **Infrastructure Layer**: Storage, transport, external APIs
- **Interface Layer**: Commands, events, DTOs

---

## ğŸ“‹ **PHASE 1: FOUNDATION ARCHITECTURE**

### **1.1 Core Domain Models**
```typescript
// Pure domain entities - no dependencies
class ChatRoom {
  constructor(
    private id: RoomId,
    private name: string,
    private participants: Map<ParticipantId, Participant>
  ) {}
  
  addParticipant(participant: Participant): DomainEvent[]
  removeParticipant(id: ParticipantId): DomainEvent[]
  addMessage(message: Message): DomainEvent[]
}

class Participant {
  constructor(
    private id: ParticipantId,
    private sessionId: SessionId,
    private capabilities: Capabilities,
    private adapter: ResponseAdapter
  ) {}
  
  canAutoRespond(): boolean
  shouldRespondTo(message: Message, room: ChatRoom): ResponseDecision
}

class Message {
  constructor(
    private id: MessageId,
    private senderId: ParticipantId,
    private content: string,
    private timestamp: Timestamp
  ) {}
  
  mentionsParticipant(id: ParticipantId): boolean
  containsKeywords(keywords: string[]): boolean
}
```

### **1.2 Domain Events**
```typescript
// Events generated by domain operations
abstract class DomainEvent {
  abstract readonly eventType: string;
  abstract readonly roomId: RoomId;
  readonly timestamp: Timestamp = new Timestamp();
}

class ParticipantJoinedEvent extends DomainEvent {
  constructor(
    readonly roomId: RoomId,
    readonly participant: Participant
  ) { super(); }
}

class MessageSentEvent extends DomainEvent {
  constructor(
    readonly roomId: RoomId,
    readonly message: Message
  ) { super(); }
}

class ResponseGeneratedEvent extends DomainEvent {
  constructor(
    readonly roomId: RoomId,
    readonly responseMessage: Message,
    readonly triggerMessage: Message,
    readonly responder: Participant
  ) { super(); }
}
```

### **1.3 Repository Interfaces (Ports)**
```typescript
// Storage ports - implemented by adapters
interface ChatRoomRepository {
  findById(id: RoomId): Promise<ChatRoom | null>;
  save(room: ChatRoom): Promise<void>;
  findByParticipant(participantId: ParticipantId): Promise<ChatRoom[]>;
}

interface MessageRepository {
  save(message: Message): Promise<void>;
  findByRoom(roomId: RoomId, limit: number): Promise<Message[]>;
  findByRoomSince(roomId: RoomId, since: Timestamp): Promise<Message[]>;
}

interface ParticipantRepository {
  findById(id: ParticipantId): Promise<Participant | null>;
  findBySession(sessionId: SessionId): Promise<Participant | null>;
  save(participant: Participant): Promise<void>;
}
```

---

## ğŸ“‹ **PHASE 2: APPLICATION SERVICES**

### **2.1 Use Cases (Application Layer)**
```typescript
// Clean use cases with single responsibility
class JoinRoomUseCase {
  constructor(
    private roomRepo: ChatRoomRepository,
    private participantRepo: ParticipantRepository,
    private eventBus: DomainEventBus
  ) {}
  
  async execute(command: JoinRoomCommand): Promise<JoinRoomResult> {
    // 1. Load or create participant
    // 2. Load room
    // 3. Add participant to room
    // 4. Save changes  
    // 5. Publish events
    // 6. Return result
  }
}

class SendMessageUseCase {
  constructor(
    private roomRepo: ChatRoomRepository,
    private messageRepo: MessageRepository,
    private responseEngine: ResponseEngine,
    private eventBus: DomainEventBus
  ) {}
  
  async execute(command: SendMessageCommand): Promise<SendMessageResult> {
    // 1. Create message
    // 2. Save message
    // 3. Add to room
    // 4. Trigger auto-responses
    // 5. Publish events
    // 6. Return result
  }
}

class ProcessAutoResponseUseCase {
  constructor(
    private roomRepo: ChatRoomRepository,
    private responseEngine: ResponseEngine,
    private eventBus: DomainEventBus
  ) {}
  
  async execute(message: Message, room: ChatRoom): Promise<void> {
    const autoResponders = room.getAutoResponders();
    
    for (const participant of autoResponders) {
      if (participant.shouldRespondTo(message, room)) {
        const response = await this.responseEngine.generateResponse(
          participant, message, room
        );
        
        if (response.success) {
          // Create response message
          // Save via SendMessageUseCase
          // Events published automatically
        }
      }
    }
  }
}
```

### **2.2 Event Bus System**
```typescript
interface DomainEventBus {
  publish(event: DomainEvent): Promise<void>;
  publishMany(events: DomainEvent[]): Promise<void>;
  subscribe<T extends DomainEvent>(
    eventType: string, 
    handler: EventHandler<T>
  ): void;
}

// Event handlers for integration
class RoomEventDistributor {
  constructor(private transport: EventTransport) {}
  
  @EventHandler(ParticipantJoinedEvent)
  async handleParticipantJoined(event: ParticipantJoinedEvent) {
    await this.transport.distributeToRoom(
      event.roomId,
      'chat:participant-joined',
      { participant: event.participant }
    );
  }
  
  @EventHandler(MessageSentEvent)
  async handleMessageSent(event: MessageSentEvent) {
    await this.transport.distributeToRoom(
      event.roomId,
      'chat:message-received',
      { message: event.message }
    );
  }
}
```

---

## ğŸ“‹ **PHASE 3: INFRASTRUCTURE ADAPTERS**

### **3.1 Storage Adapters**
```typescript
// DataDaemon integration
class DataDaemonChatRoomRepository implements ChatRoomRepository {
  constructor(private dataDaemon: DataDaemon) {}
  
  async findById(id: RoomId): Promise<ChatRoom | null> {
    const data = await this.dataDaemon.read({
      collection: 'chat_rooms',
      id: id.value
    });
    
    return data ? this.toDomain(data) : null;
  }
  
  async save(room: ChatRoom): Promise<void> {
    await this.dataDaemon.create({
      collection: 'chat_rooms',
      data: this.toData(room)
    });
  }
  
  private toDomain(data: any): ChatRoom { /* mapping logic */ }
  private toData(room: ChatRoom): any { /* mapping logic */ }
}

// In-memory adapter for development
class InMemoryChatRoomRepository implements ChatRoomRepository {
  private rooms = new Map<string, ChatRoom>();
  
  async findById(id: RoomId): Promise<ChatRoom | null> {
    return this.rooms.get(id.value) || null;
  }
  
  async save(room: ChatRoom): Promise<void> {
    this.rooms.set(room.id.value, room);
  }
}
```

### **3.2 Transport Adapters**
```typescript
// JTAG Router integration
class JTAGEventTransport implements EventTransport {
  constructor(
    private router: JTAGRouter,
    private subscriptionManager: RoomSubscriptionManager
  ) {}
  
  async distributeToRoom(
    roomId: RoomId, 
    eventType: string, 
    data: any
  ): Promise<void> {
    const subscribers = this.subscriptionManager.getSubscribers(roomId);
    
    const promises = subscribers.map(sessionId => 
      this.router.sendMessage({
        endpoint: 'chat/room-event',
        payload: {
          eventType,
          data,
          roomId: roomId.value,
          targetSessionId: sessionId.value
        }
      })
    );
    
    await Promise.allSettled(promises);
  }
}
```

### **3.3 Response Engine Adapters**
```typescript
// AI Provider adapters
class OpenAIResponseAdapter implements ResponseProvider {
  constructor(private apiKey: string) {}
  
  async generateResponse(request: ResponseRequest): Promise<ResponseResult> {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${this.apiKey}` },
      body: JSON.stringify({
        model: request.config.model || 'gpt-3.5-turbo',
        messages: this.buildMessages(request),
        max_tokens: 150
      })
    });
    
    const data = await response.json();
    return {
      content: data.choices[0]?.message?.content || '',
      processingTime: Date.now() - request.startTime
    };
  }
}

// Universal response engine using adapters
class AdapterBasedResponseEngine implements ResponseEngine {
  private adapters = new Map<string, ResponseProvider>();
  
  registerAdapter(type: string, adapter: ResponseProvider) {
    this.adapters.set(type, adapter);
  }
  
  async generateResponse(
    participant: Participant,
    message: Message,
    room: ChatRoom
  ): Promise<ResponseResult> {
    const adapter = this.adapters.get(participant.adapterType);
    if (!adapter) {
      throw new Error(`No adapter for type: ${participant.adapterType}`);
    }
    
    return await adapter.generateResponse({
      participant,
      triggerMessage: message,
      room,
      context: room.getRecentMessages(10)
    });
  }
}
```

---

## ğŸ“‹ **PHASE 4: INTERFACE LAYER**

### **4.1 JTAG Command Integration**
```typescript
// Chat commands following JTAG patterns
class ChatJoinRoomCommand extends BaseCommand {
  async execute(params: ChatJoinRoomParams): Promise<ChatJoinRoomResult> {
    const command = new JoinRoomCommand({
      sessionId: new SessionId(params.sessionId),
      roomId: new RoomId(params.roomId),
      participantName: params.participantName,
      capabilities: params.capabilities,
      adapter: params.adapter
    });
    
    return await this.joinRoomUseCase.execute(command);
  }
}

class ChatSendMessageCommand extends BaseCommand {
  async execute(params: ChatSendMessageParams): Promise<ChatSendMessageResult> {
    const command = new SendMessageCommand({
      sessionId: new SessionId(params.sessionId),
      roomId: new RoomId(params.roomId),
      content: params.content,
      mentions: params.mentions?.map(id => new ParticipantId(id))
    });
    
    return await this.sendMessageUseCase.execute(command);
  }
}
```

### **4.2 Event Handlers for Browser Integration**
```typescript
// Browser widget event integration
class BrowserChatEventHandler {
  constructor(private webSocketTransport: WebSocketTransport) {}
  
  @EventHandler('chat:message-received')
  async handleMessageReceived(event: ChatMessageEventData) {
    // Send to browser via WebSocket
    await this.webSocketTransport.sendToBrowser(event.roomId, {
      type: 'CHAT_MESSAGE_RECEIVED',
      payload: {
        message: event.message,
        roomId: event.roomId
      }
    });
  }
  
  @EventHandler('chat:participant-joined')
  async handleParticipantJoined(event: ParticipantJoinedEventData) {
    await this.webSocketTransport.sendToBrowser(event.roomId, {
      type: 'CHAT_PARTICIPANT_JOINED',
      payload: {
        participant: event.participant,
        roomId: event.roomId
      }
    });
  }
}
```

---

## ğŸ“‹ **PHASE 5: DEPENDENCY INJECTION & COMPOSITION**

### **5.1 Container Configuration**
```typescript
// Clean dependency injection
class ChatDaemonContainer {
  // Repositories
  private roomRepository: ChatRoomRepository;
  private messageRepository: MessageRepository;
  private participantRepository: ParticipantRepository;
  
  // Use cases
  private joinRoomUseCase: JoinRoomUseCase;
  private sendMessageUseCase: SendMessageUseCase;
  private processAutoResponseUseCase: ProcessAutoResponseUseCase;
  
  // Infrastructure
  private eventBus: DomainEventBus;
  private responseEngine: ResponseEngine;
  private eventTransport: EventTransport;
  
  constructor(config: ChatDaemonConfig) {
    this.wireUpDependencies(config);
  }
  
  private wireUpDependencies(config: ChatDaemonConfig) {
    // Storage layer
    if (config.storage.type === 'datadaemon') {
      this.roomRepository = new DataDaemonChatRoomRepository(config.dataDaemon);
      this.messageRepository = new DataDaemonMessageRepository(config.dataDaemon);
      this.participantRepository = new DataDaemonParticipantRepository(config.dataDaemon);
    } else {
      this.roomRepository = new InMemoryChatRoomRepository();
      this.messageRepository = new InMemoryMessageRepository();
      this.participantRepository = new InMemoryParticipantRepository();
    }
    
    // Transport layer
    this.eventTransport = new JTAGEventTransport(
      config.router,
      new RoomSubscriptionManager()
    );
    
    // Event bus
    this.eventBus = new InMemoryEventBus();
    this.eventBus.subscribe('ParticipantJoinedEvent', new RoomEventDistributor(this.eventTransport));
    this.eventBus.subscribe('MessageSentEvent', new RoomEventDistributor(this.eventTransport));
    
    // Response engine
    this.responseEngine = new AdapterBasedResponseEngine();
    this.responseEngine.registerAdapter('openai', new OpenAIResponseAdapter(config.openAIKey));
    this.responseEngine.registerAdapter('anthropic', new AnthropicResponseAdapter(config.anthropicKey));
    
    // Use cases
    this.joinRoomUseCase = new JoinRoomUseCase(
      this.roomRepository,
      this.participantRepository,
      this.eventBus
    );
    
    this.sendMessageUseCase = new SendMessageUseCase(
      this.roomRepository,
      this.messageRepository,
      this.responseEngine,
      this.eventBus
    );
    
    this.processAutoResponseUseCase = new ProcessAutoResponseUseCase(
      this.roomRepository,
      this.responseEngine,
      this.eventBus
    );
  }
  
  getChatCommands(): ChatCommand[] {
    return [
      new ChatJoinRoomCommand(this.joinRoomUseCase),
      new ChatSendMessageCommand(this.sendMessageUseCase),
      new ChatListRoomsCommand(this.roomRepository),
      new ChatGetHistoryCommand(this.messageRepository)
    ];
  }
}
```

---

## ğŸ“‹ **PHASE 6: TESTING STRATEGY**

### **6.1 Unit Tests (Domain Layer)**
```typescript
describe('ChatRoom Domain Logic', () => {
  test('adding participant generates ParticipantJoinedEvent', () => {
    const room = new ChatRoom(roomId, 'Test Room');
    const participant = new Participant(participantId, sessionId, capabilities);
    
    const events = room.addParticipant(participant);
    
    expect(events).toHaveLength(1);
    expect(events[0]).toBeInstanceOf(ParticipantJoinedEvent);
  });
  
  test('participant auto-response logic', () => {
    const participant = new Participant(id, sessionId, {autoResponds: true});
    const message = new Message(msgId, senderId, 'Hello @participant');
    
    const decision = participant.shouldRespondTo(message, room);
    
    expect(decision.shouldRespond).toBe(true);
    expect(decision.reason).toBe('mentioned');
  });
});
```

### **6.2 Integration Tests (Application Layer)**
```typescript
describe('SendMessage Use Case', () => {
  test('sends message and triggers auto-responses', async () => {
    const mockRepo = new InMemoryMessageRepository();
    const mockEventBus = new MockEventBus();
    const useCase = new SendMessageUseCase(mockRepo, mockEventBus);
    
    const result = await useCase.execute(sendMessageCommand);
    
    expect(result.success).toBe(true);
    expect(mockEventBus.publishedEvents).toHaveLength(2); // Message + Response
  });
});
```

### **6.3 End-to-End Tests**
```typescript
describe('Full Chat Flow', () => {
  test('human message triggers AI response in browser', async () => {
    // 1. Human joins room via browser
    await chatWidget.joinRoom('room123');
    
    // 2. AI joins room via adapter
    await aiAdapter.joinRoom('room123');
    
    // 3. Human sends message
    await chatWidget.sendMessage('Hello AI!');
    
    // 4. Verify AI receives event and responds
    await waitFor(() => {
      expect(chatWidget.messages).toHaveLength(2); // Human + AI response
    });
  });
});
```

---

## ğŸ“… **IMPLEMENTATION TIMELINE**

### **Week 1: Foundation**
- Day 1-2: Domain models and events
- Day 3-4: Repository interfaces and in-memory implementations
- Day 5: Basic use cases (JoinRoom, SendMessage)

### **Week 2: Application Layer**
- Day 1-2: Complete use cases with event publishing
- Day 3-4: Response engine with adapter pattern
- Day 5: Event bus and handler system

### **Week 3: Infrastructure**
- Day 1-2: DataDaemon storage adapters
- Day 3-4: JTAG transport integration
- Day 5: AI provider adapters (OpenAI, Anthropic)

### **Week 4: Integration**
- Day 1-2: JTAG command integration
- Day 3-4: Browser event handling
- Day 5: End-to-end testing and bug fixes

### **Week 5: Polish & Deploy**
- Day 1-2: Error handling and edge cases
- Day 3-4: Performance optimization
- Day 5: Documentation and deployment

---

## ğŸ¯ **SUCCESS METRICS**

### **Technical Metrics**
- âœ… Zero `any` types (100% type safety)
- âœ… <100ms event delivery latency
- âœ… 95%+ test coverage on domain logic
- âœ… Zero circular dependencies

### **Functional Metrics** 
- âœ… Human-AI chat works in browser
- âœ… Multiple AI providers working
- âœ… Room subscriptions working correctly
- âœ… Message history persistence
- âœ… Auto-response triggers working

### **Architecture Metrics**
- âœ… Clean dependency flow (inward-facing)
- âœ… Single responsibility per class
- âœ… Testable without infrastructure
- âœ… Configurable adapters for all external systems

This plan ensures we build a **clean, testable, maintainable** universal chat system that truly achieves the **85% code reduction** through elegant abstraction while maintaining **bulletproof type safety**.