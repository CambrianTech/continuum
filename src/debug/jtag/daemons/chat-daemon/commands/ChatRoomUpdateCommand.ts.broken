/**
 * Chat Room Update Command - Universal Handler
 * 
 * BREAKTHROUGH: This single command handler works for:
 * - Browser chat widgets (updates UI)
 * - AI adapters (evaluates for auto-response)  
 * - Persona adapters (generates persona-specific responses)
 * - Webhook integrations (forwards to external systems)
 * 
 * Location Transparent: Handles updates from local or remote nodes identically
 * Session Targeted: Only processes updates for relevant sessions
 */

import { CommandBase } from '../../command-daemon/shared/CommandBase';
import type { JTAGContext } from '../../../system/core/types/JTAGTypes';
import type { JTAGRouter } from '../../../system/core/router/shared/JTAGRouter';
import type { 
  ChatRoomUpdateParams,
  ChatRoomUpdateResult,
  SessionParticipant,
  ChatMessage,
  RoomUpdateType
} from '../shared/ChatTypes';
import { 
  createChatRoomUpdateResult,
  ResponseContext
} from '../shared/ChatTypes';
import { UniversalResponseEngine } from '../shared/UniversalResponseEngine';

/**
 * Universal Chat Room Update Handler
 * 
 * Processes room updates and delegates to appropriate handlers based on context
 */
export class ChatRoomUpdateCommand extends CommandBase {
  public readonly subpath = 'room-update';
  
  // Universal response engine for auto-responders
  private responseEngine = new UniversalResponseEngine();
  
  // Track which rooms this handler cares about (subscription-like behavior)
  protected subscribedRooms = new Set<string>();
  
  // Handler-specific participant info (set by subclasses)
  protected participant?: SessionParticipant;

  constructor(context: JTAGContext, router: JTAGRouter) {
    super('chat-room-update', context, router);
  }

  /**
   * Main command execution - delegates based on update type and context
   */
  async execute(params: ChatRoomUpdateParams): Promise<ChatRoomUpdateResult> {
    console.log(`üì® ChatRoomUpdate: Received ${params.updateType} for room ${params.roomId} from node ${params.originNodeId || 'local'}`);
    
    // Session filtering: Only process if this update targets our session or is room-wide
    if (params.targetSessionId && params.targetSessionId !== this.context.uuid) {
      console.log(`üéØ ChatRoomUpdate: Skipping - targeted at ${params.targetSessionId}, we are ${this.context.uuid}`);
      return createChatRoomUpdateResult(this.context, this.context.uuid, {
        success: true,
        processed: false,
        roomId: params.roomId,
        updateType: params.updateType,
        timestamp: new Date().toISOString()
      });
    }
    
    // Room subscription filtering: Only process updates for rooms we care about
    if (this.subscribedRooms.size > 0 && !this.subscribedRooms.has(params.roomId)) {
      console.log(`üè† ChatRoomUpdate: Skipping - not subscribed to room ${params.roomId}`);
      return createChatRoomUpdateResult(this.context, this.context.uuid, {
        success: true,
        processed: false,
        roomId: params.roomId,
        updateType: params.updateType
      });
    }
    
    try {
      // Delegate to specific handler based on update type
      await this.handleRoomUpdate(params);
      
      console.log(`‚úÖ ChatRoomUpdate: Successfully processed ${params.updateType} for room ${params.roomId}`);
      
      return createChatRoomUpdateResult(this.context, this.context.uuid, {
        success: true,
        processed: true,
        roomId: params.roomId,
        updateType: params.updateType
      });
      
    } catch (error) {
      console.error(`‚ùå ChatRoomUpdate: Failed to process ${params.updateType} for room ${params.roomId}:`, error);
      
      return createChatRoomUpdateResult(this.context, this.context.uuid, {
        success: false,
        processed: false,
        roomId: params.roomId,
        updateType: params.updateType,
        error: {
          message: error instanceof Error ? error.message : 'Unknown error',
          code: 'ROOM_UPDATE_ERROR',
          type: 'processing' as const,
          name: 'RoomUpdateError',
          timestamp: new Date().toISOString(),
          toJSON: () => ({ message: error instanceof Error ? error.message : 'Unknown error', code: 'ROOM_UPDATE_ERROR' })
        }
      });
    }
  }

  /**
   * Handle room update - override in subclasses for specific behavior
   * 
   * This method is called after filtering and provides clean delegation
   */
  protected async handleRoomUpdate(params: ChatRoomUpdateParams): Promise<void> {
    switch (params.updateType) {
      case 'message-sent':
        await this.handleMessageSent(params);
        break;
        
      case 'participant-joined':
        await this.handleParticipantJoined(params);
        break;
        
      case 'participant-left':
        await this.handleParticipantLeft(params);
        break;
        
      case 'participant-response':
        await this.handleParticipantResponse(params);
        break;
        
      case 'room-state-changed':
        await this.handleRoomStateChanged(params);
        break;
        
      default:
        console.warn(`‚ö†Ô∏è ChatRoomUpdate: Unknown update type: ${params.updateType}`);
    }
  }

  /**
   * Handle new message in room
   * 
   * Base implementation: Log the message
   * Subclasses override for specific behavior (UI update, auto-response, etc.)
   */
  protected async handleMessageSent(params: ChatRoomUpdateParams): Promise<void> {
    const message = params.data.message;
    if (!message) {
      console.warn('‚ö†Ô∏è ChatRoomUpdate: message-sent update missing message data');
      return;
    }
    
    console.log(`üí¨ New message in room ${params.roomId}: ${message.senderName}: ${message.content}`);
    
    // Base implementation: Check for auto-response if this handler represents an auto-responder
    if (this.participant?.capabilities?.autoResponds) {
      await this.evaluateAutoResponse(params.roomId, message);
    }
  }\n\n  /**\n   * Handle participant joined room\n   */\n  protected async handleParticipantJoined(params: ChatRoomUpdateParams): Promise<void> {\n    const participant = params.data.participant;\n    if (!participant) {\n      console.warn('‚ö†Ô∏è ChatRoomUpdate: participant-joined update missing participant data');\n      return;\n    }\n    \n    console.log(`üëã ${participant.displayName} joined room ${params.roomId}`);\n  }\n\n  /**\n   * Handle participant left room\n   */\n  protected async handleParticipantLeft(params: ChatRoomUpdateParams): Promise<void> {\n    const participant = params.data.participant;\n    const reason = params.data.reason || 'unknown';\n    \n    if (!participant) {\n      console.warn('‚ö†Ô∏è ChatRoomUpdate: participant-left update missing participant data');\n      return;\n    }\n    \n    console.log(`üëã ${participant.displayName} left room ${params.roomId} (${reason})`);\n  }\n\n  /**\n   * Handle participant response (AI, bot, etc. generated a response)\n   */\n  protected async handleParticipantResponse(params: ChatRoomUpdateParams): Promise<void> {\n    const responseMessage = params.data.message;\n    if (!responseMessage) {\n      console.warn('‚ö†Ô∏è ChatRoomUpdate: participant-response update missing message data');\n      return;\n    }\n    \n    console.log(`ü§ñ Auto-response in room ${params.roomId}: ${responseMessage.senderName}: ${responseMessage.content}`);\n  }\n\n  /**\n   * Handle room state change (participant list update, room settings, etc.)\n   */\n  protected async handleRoomStateChanged(params: ChatRoomUpdateParams): Promise<void> {\n    console.log(`üîÑ Room ${params.roomId} state changed:`, params.data.metadata);\n  }\n\n  /**\n   * Evaluate whether to generate auto-response\n   * \n   * Uses UniversalResponseEngine for consistent auto-response logic\n   */\n  protected async evaluateAutoResponse(roomId: string, message: ChatMessage): Promise<void> {\n    if (!this.participant) {\n      return; // No participant context\n    }\n    \n    try {\n      // Create minimal room context for response evaluation\n      const roomContext = {\n        roomId,\n        participants: [], // Would be populated in real implementation\n        messageHistory: []  // Would be populated in real implementation\n      } as any;\n      \n      // Check if we should respond\n      const decision = this.responseEngine.shouldRespond(this.participant, message, roomContext);\n      \n      if (decision.shouldRespond) {\n        console.log(`ü§ñ ${this.participant.displayName}: Generating response (${decision.reason})`);\n        \n        // Generate response using universal engine\n        const result = await this.responseEngine.generateResponse(\n          this.participant,\n          message,\n          roomContext,\n          [] // Message history would be provided in real implementation\n        );\n        \n        if (result.success && result.content) {\n          // Send response via chat/send-message command\n          await this.sendResponse(roomId, result.content, message);\n        }\n      }\n      \n    } catch (error) {\n      console.error(`‚ùå Auto-response evaluation failed for ${this.participant.displayName}:`, error);\n    }\n  }\n\n  /**\n   * Send auto-response message\n   * \n   * This uses the standard chat/send-message command, maintaining consistency\n   */\n  protected async sendResponse(roomId: string, content: string, originalMessage: ChatMessage): Promise<void> {\n    if (!this.participant) {\n      return;\n    }\n    \n    try {\n      // Use standard chat command to send response\n      const result = await this.router?.postMessage({\n        endpoint: 'chat/send-message',\n        payload: {\n          context: this.context,\n          sessionId: this.context.uuid,\n          roomId,\n          content,\n          category: 'response',\n          mentions: [], // Could mention original sender\n          replyToId: originalMessage.messageId\n        },\n        origin: `${this.context.environment}/chat-room-update`,\n        context: this.context,\n        messageType: 'request',\n        correlationId: `response_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`\n      });\n      \n      console.log(`‚úÖ ${this.participant.displayName}: Response sent to room ${roomId}`);\n      \n    } catch (error) {\n      console.error(`‚ùå Failed to send response from ${this.participant.displayName}:`, error);\n    }\n  }\n\n  /**\n   * Subscribe to room updates\n   * \n   * Handlers call this to indicate which rooms they care about\n   */\n  public subscribeToRoom(roomId: string): void {\n    this.subscribedRooms.add(roomId);\n    console.log(`üîî Subscribed to room ${roomId} updates`);\n  }\n\n  /**\n   * Unsubscribe from room updates\n   */\n  public unsubscribeFromRoom(roomId: string): void {\n    this.subscribedRooms.delete(roomId);\n    console.log(`üîï Unsubscribed from room ${roomId} updates`);\n  }\n\n  /**\n   * Set participant context for this handler\n   * \n   * This enables auto-response evaluation and response generation\n   */\n  public setParticipant(participant: SessionParticipant): void {\n    this.participant = participant;\n    console.log(`üë§ Set participant context: ${participant.displayName} (autoResponds: ${participant.capabilities?.autoResponds})`);\n  }\n\n  /**\n   * Get handler statistics\n   */\n  public getStats() {\n    return {\n      subscribedRooms: Array.from(this.subscribedRooms),\n      participant: this.participant ? {\n        name: this.participant.displayName,\n        autoResponds: this.participant.capabilities?.autoResponds || false,\n        adapterType: this.participant.adapter?.type\n      } : null,\n      context: {\n        environment: this.context.environment,\n        sessionId: this.context.uuid\n      }\n    };\n  }\n}