/**
 * User Entity - Decorated UserData for field extraction
 *
 * Uses field decorators to define storage requirements for the serde-style adapter system
 * Replaces manual field mappings with elegant decorator-based schema definition
 */

import type { UUID } from '../../core/types/CrossPlatformUUID';

// User-specific types moved here since domain files are deleted
export type UserType = 'human' | 'agent' | 'persona' | 'system';
export type UserStatus = 'online' | 'offline' | 'away' | 'busy';

export interface UserProfile {
  displayName: string;
  avatar: string;
  bio: string;
  location: string;
  joinedAt: Date;
}

export interface UserCapabilities {
  canSendMessages: boolean;
  canReceiveMessages: boolean;
  canCreateRooms: boolean;
  canInviteOthers: boolean;
  canModerate: boolean;
  autoResponds: boolean;
  providesContext: boolean;
  canTrain: boolean;
  canAccessPersonas: boolean;
}

export interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: string;
  timezone: string;
  notifications: {
    mentions: boolean;
    directMessages: boolean;
    roomUpdates: boolean;
  };
  privacy: {
    showOnlineStatus: boolean;
    allowDirectMessages: boolean;
    shareActivity: boolean;
  };
}

import {
  PrimaryField,
  TextField,
  DateField,
  EnumField,
  JsonField,
  ForeignKeyField,
  TEXT_LENGTH
} from '../decorators/FieldDecorators';
import { BaseEntity } from './BaseEntity';

/**
 * Decorated User Entity - Storage-aware version of UserData
 *
 * The decorators define which fields get extracted to dedicated columns
 * vs stored as JSON blobs for optimal query performance
 */
export class UserEntity extends BaseEntity {
  // Single source of truth for collection name - used by both decorators and commands
  static readonly collection = 'User';

  @ForeignKeyField({ references: 'personas.id', nullable: true })
  personaId?: UUID;

  @EnumField({ index: true })
  type: UserType;

  @TextField({ index: true })
  displayName: string;

  @TextField({ maxLength: TEXT_LENGTH.SHORT })
  shortDescription: string;

  @EnumField({ index: true })
  status: UserStatus;

  @DateField({ index: true })
  lastActiveAt: Date;

  // Complex objects stored as JSON blobs
  @JsonField()
  profile: UserProfile;

  @JsonField()
  capabilities: UserCapabilities;

  @JsonField()
  preferences: UserPreferences;

  @JsonField()
  sessionsActive: readonly UUID[];

  // Index signature for compatibility
  [key: string]: unknown;

  constructor() {
    super(); // Initialize BaseEntity fields (id, createdAt, updatedAt, version)

    // Default values - id autogenerated by BaseEntity
    this.type = 'human';
    this.displayName = '';
    this.shortDescription = '';
    this.status = 'offline';
    this.lastActiveAt = new Date();
    this.profile = { displayName: '', avatar: '', bio: '', location: '', joinedAt: new Date() };
    this.capabilities = { canSendMessages: true, canReceiveMessages: true, canCreateRooms: false, canInviteOthers: false, canModerate: false, autoResponds: false, providesContext: false, canTrain: false, canAccessPersonas: false };
    this.preferences = { theme: 'auto', language: 'en', timezone: 'UTC', notifications: { mentions: true, directMessages: true, roomUpdates: false }, privacy: { showOnlineStatus: true, allowDirectMessages: true, shareActivity: false } };
    this.sessionsActive = [];
  }

  /**
   * Implement BaseEntity abstract method
   */
  get collection(): string {
    return UserEntity.collection;
  }

  /**
   * Implement BaseEntity abstract method - validate user data
   */
  validate(): { success: boolean; error?: string } {
    // Required fields validation
    if (!this.displayName?.trim()) {
      return { success: false, error: 'User displayName is required' };
    }

    if (this.displayName.length > 100) {
      return { success: false, error: 'User displayName must be 100 characters or less' };
    }

    // Enum validation
    const validTypes: UserType[] = ['human', 'agent', 'persona', 'system'];
    if (!validTypes.includes(this.type)) {
      return { success: false, error: `User type must be one of: ${validTypes.join(', ')}` };
    }

    const validStatuses: UserStatus[] = ['online', 'offline', 'away', 'busy'];
    if (!validStatuses.includes(this.status)) {
      return { success: false, error: `User status must be one of: ${validStatuses.join(', ')}` };
    }

    // Profile validation
    if (this.profile) {
      if (!this.profile.displayName?.trim()) {
        return { success: false, error: 'User profile.displayName is required' };
      }
      if (this.profile.displayName !== this.displayName) {
        return { success: false, error: 'User profile.displayName must match displayName field' };
      }
    }

    // Date validation
    if (!(this.lastActiveAt instanceof Date) || isNaN(this.lastActiveAt.getTime())) {
      return { success: false, error: 'User lastActiveAt must be a valid Date' };
    }

    return { success: true };
  }
}