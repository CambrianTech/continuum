/**
 * ChatMessage Entity - Decorated ChatMessageData for field extraction
 *
 * Uses field decorators to define storage requirements for the serde-style adapter system
 */

import type { UUID } from '../../core/types/CrossPlatformUUID';

// Message-specific types moved here since domain files are deleted
export type MessageStatus = 'sending' | 'sent' | 'delivered' | 'read' | 'failed' | 'deleted';
export type MessagePriority = 'low' | 'normal' | 'high' | 'urgent';

export interface MessageContent {
  text: string;
  attachments: readonly any[];
}

export interface MessageMetadata {
  source: 'user' | 'system' | 'bot' | 'webhook';
  deviceType?: string;
  clientVersion?: string;
  editHistory?: readonly any[];
  deliveryReceipts?: readonly any[];
}

// Constants and utility functions that were in the domain file
export const MESSAGE_STATUS = {
  SENDING: 'sending' as const,
  SENT: 'sent' as const,
  DELIVERED: 'delivered' as const,
  READ: 'read' as const,
  FAILED: 'failed' as const,
  DELETED: 'deleted' as const,
} as const;

// Data creation interface for new messages
export interface CreateMessageData {
  roomId: UUID;
  senderId: UUID;
  senderName: string;
  content: MessageContent;
  priority?: MessagePriority;
  metadata?: Partial<MessageMetadata>;
  replyToId?: UUID;
}

// Simple content processing - no formatting complexity
export function processMessageFormatting(content: MessageContent): MessageContent {
  return {
    text: content.text,
    attachments: content.attachments
  };
}

import {
  PrimaryField,
  TextField,
  DateField,
  EnumField,
  JsonField
} from '../decorators/FieldDecorators';
import { BaseEntity } from './BaseEntity';

/**
 * Decorated ChatMessage Entity - Storage-aware version of ChatMessageData
 *
 * The decorators define which fields get extracted to dedicated columns
 * vs stored as JSON blobs for optimal query performance
 */
export class ChatMessageEntity extends BaseEntity {
  // Single source of truth for collection name - used by both decorators and commands
  static readonly collection = 'ChatMessage';

  @TextField({ index: true })
  roomId: UUID;

  @TextField({ index: true })
  senderId: UUID;

  @TextField()
  senderName: string;

  @JsonField()
  content: MessageContent;

  @EnumField()
  status: MessageStatus;

  @EnumField()
  priority: MessagePriority;

  @DateField({ index: true })
  timestamp: Date;

  @DateField({ nullable: true })
  editedAt?: Date;

  @JsonField()
  reactions: readonly any[];

  @JsonField({ nullable: true })
  thread?: any;

  @TextField({ nullable: true })
  replyToId?: UUID;


  constructor() {
    super(); // Initialize BaseEntity fields (id, createdAt, updatedAt, version)

    // Default values - id autogenerated by BaseEntity
    this.roomId = '' as UUID;
    this.senderId = '' as UUID;
    this.senderName = '';
    this.content = { text: '', attachments: [] };
    this.status = 'sending';
    this.priority = 'normal';
    this.timestamp = new Date();
    this.reactions = [];
  }

  /**
   * Implement BaseEntity abstract method
   */
  get collection(): string {
    return ChatMessageEntity.collection;
  }

  /**
   * Implement BaseEntity abstract method - validate message data
   */
  validate(): { success: boolean; error?: string } {
    // Required fields validation
    if (!this.roomId?.trim()) {
      return { success: false, error: 'Message roomId is required' };
    }

    if (!this.senderId?.trim()) {
      return { success: false, error: 'Message senderId is required' };
    }

    if (!this.senderName?.trim()) {
      return { success: false, error: 'Message senderName is required' };
    }

    if (!this.content) {
      return { success: false, error: 'Message content is required' };
    }

    if (!this.content.text?.trim() && (!this.content.attachments || this.content.attachments.length === 0)) {
      return { success: false, error: 'Message must have either text content or attachments' };
    }

    // Enum validation
    const validStatuses: MessageStatus[] = ['sending', 'sent', 'delivered', 'read', 'failed', 'deleted'];
    if (!validStatuses.includes(this.status)) {
      return { success: false, error: `Message status must be one of: ${validStatuses.join(', ')}` };
    }

    const validPriorities: MessagePriority[] = ['low', 'normal', 'high', 'urgent'];
    if (!validPriorities.includes(this.priority)) {
      return { success: false, error: `Message priority must be one of: ${validPriorities.join(', ')}` };
    }

    // Date validation
    if (!(this.timestamp instanceof Date) || isNaN(this.timestamp.getTime())) {
      return { success: false, error: 'Message timestamp must be a valid Date' };
    }

    return { success: true };
  }

}