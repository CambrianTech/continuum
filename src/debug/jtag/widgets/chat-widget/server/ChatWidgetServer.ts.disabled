/**
 * ChatWidgetServer - Server-side chat coordination
 * 
 * Handles all complex business logic:
 * - Database integration for message persistence
 * - Router events for multi-user coordination  
 * - AI agent integration via Academy daemon
 * - Session and user management
 * - Real-time WebSocket coordination
 */

import { BaseDaemon } from '../../../daemons/base/BaseDaemon';
import { DaemonMessage, DaemonResponse } from '../../../daemons/base/DaemonProtocol';
import { ChatMessage, ChatRoom, ChatUser, ChatWidgetConfig } from '../shared/ChatTypes';

export interface ChatMessageRequest {
  content: string;
  roomId: string;
  userId: string;
  messageType?: 'user' | 'system';
  metadata?: Record<string, any>;
}

export interface ChatHistoryRequest {
  roomId: string;
  limit?: number;
  before?: string; // Message ID for pagination
}

export class ChatWidgetServer extends BaseDaemon {
  public readonly name = 'chat-widget';
  public readonly version = '1.0.0';
  
  private activeRooms = new Map<string, ChatRoom>();
  private userSessions = new Map<string, ChatUser>();
  private messageCache = new Map<string, ChatMessage[]>(); // Room ID -> messages
  
  constructor(private config: ChatWidgetConfig = {}) {
    super();
  }

  protected async onStart(): Promise<void> {
    this.log('üéØ Starting ChatWidgetServer with daemon integration...');
    
    // Initialize chat rooms
    await this.initializeChatRooms();
    
    // Setup daemon event listeners
    this.setupDaemonEventListeners();
    
    this.log('‚úÖ ChatWidgetServer ready for coordination');
  }

  protected async onStop(): Promise<void> {
    this.log('üõë Stopping ChatWidgetServer...');
    this.activeRooms.clear();
    this.userSessions.clear();
    this.messageCache.clear();
  }

  getMessageTypes(): string[] {
    return [
      'chat-widget:send_message',
      'chat-widget:get_history', 
      'chat-widget:join_room',
      'chat-widget:leave_room',
      'chat-widget:get_users',
      'chat-widget:typing_indicator'
    ];
  }

  protected async handleMessage(message: DaemonMessage): Promise<DaemonResponse<any>> {
    try {
      switch (message.type) {
        case 'chat-widget:send_message':
          return await this.handleSendMessage(message.data);
          
        case 'chat-widget:get_history':
          return await this.handleGetHistory(message.data);
          
        case 'chat-widget:join_room':
          return await this.handleJoinRoom(message.data);
          
        case 'chat-widget:leave_room':
          return await this.handleLeaveRoom(message.data);
          
        case 'chat-widget:get_users':
          return await this.handleGetUsers(message.data);
          
        case 'chat-widget:typing_indicator':
          return await this.handleTypingIndicator(message.data);
          
        default:
          return {
            success: false,
            error: `Unknown message type: ${message.type}`
          };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: `Chat widget operation failed: ${errorMessage}`
      };
    }
  }

  // === MESSAGE HANDLERS ===

  private async handleSendMessage(request: ChatMessageRequest): Promise<DaemonResponse> {
    const { content, roomId, userId, messageType = 'user', metadata = {} } = request;
    
    this.log(`üí¨ Processing message from ${userId} in room ${roomId}`);
    
    try {
      // Create message object
      const message: ChatMessage = {
        id: this.generateMessageId(),
        content,
        roomId,
        userId,
        type: messageType,
        timestamp: new Date().toISOString(),
        metadata
      };

      // Store in database via database daemon
      await this.storeMessage(message);
      
      // Add to cache for fast retrieval
      this.addToMessageCache(roomId, message);
      
      // Broadcast to room via router daemon
      await this.broadcastToRoom(roomId, 'message_received', message);
      
      // If user message, process AI response
      if (messageType === 'user') {
        this.processAIResponse(message).catch(error => {
          this.log(`‚ö†Ô∏è AI response failed for message ${message.id}: ${error.message}`, 'warn');
        });
      }
      
      return {
        success: true,
        data: {
          message,
          messageId: message.id,
          timestamp: message.timestamp
        }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.log(`‚ùå Failed to send message: ${errorMessage}`, 'error');
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  private async handleGetHistory(request: ChatHistoryRequest): Promise<DaemonResponse> {
    const { roomId, limit = 50, before } = request;
    
    try {
      // Check cache first
      let messages = this.messageCache.get(roomId) || [];
      
      if (messages.length === 0) {
        // Load from database via database daemon
        messages = await this.loadMessagesFromDatabase(roomId, limit, before);
        this.messageCache.set(roomId, messages);
      }
      
      // Apply pagination if needed
      if (before) {
        const beforeIndex = messages.findIndex(m => m.id === before);
        messages = beforeIndex > 0 ? messages.slice(Math.max(0, beforeIndex - limit), beforeIndex) : [];
      } else {
        messages = messages.slice(-limit);
      }
      
      return {
        success: true,
        data: {
          messages,
          roomId,
          totalCount: messages.length,
          hasMore: messages.length === limit // Simple heuristic
        }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: `Failed to load chat history: ${errorMessage}`
      };
    }
  }

  private async handleJoinRoom(data: { roomId: string; userId: string }): Promise<DaemonResponse> {
    const { roomId, userId } = data;
    
    try {
      // Get user info
      const user = await this.getUserInfo(userId);
      
      // Add to room
      const room = this.activeRooms.get(roomId);
      if (room) {
        room.users.set(userId, user);
      }
      
      // Broadcast join event
      await this.broadcastToRoom(roomId, 'user_joined', { user, roomId });
      
      // Send welcome message
      const welcomeMessage: ChatMessage = {
        id: this.generateMessageId(),
        content: `${user.name} joined the room`,
        roomId,
        userId: 'system',
        type: 'system',
        timestamp: new Date().toISOString(),
        metadata: { systemEvent: 'user_joined' }
      };
      
      await this.storeMessage(welcomeMessage);
      await this.broadcastToRoom(roomId, 'message_received', welcomeMessage);
      
      return {
        success: true,
        data: { roomId, user, message: 'Joined successfully' }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  private async handleLeaveRoom(data: { roomId: string; userId: string }): Promise<DaemonResponse> {
    const { roomId, userId } = data;
    
    try {
      const room = this.activeRooms.get(roomId);
      const user = room?.users.get(userId);
      
      if (room && user) {
        room.users.delete(userId);
        
        // Broadcast leave event
        await this.broadcastToRoom(roomId, 'user_left', { user, roomId });
      }
      
      return {
        success: true,
        data: { roomId, userId, message: 'Left successfully' }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  private async handleGetUsers(data: { roomId: string }): Promise<DaemonResponse> {
    const { roomId } = data;
    
    try {
      const room = this.activeRooms.get(roomId);
      const users = room ? Array.from(room.users.values()) : [];
      
      return {
        success: true,
        data: { roomId, users, userCount: users.length }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  private async handleTypingIndicator(data: { roomId: string; userId: string; isTyping: boolean }): Promise<DaemonResponse> {
    const { roomId, userId, isTyping } = data;
    
    try {
      // Broadcast typing status to room (except sender)
      await this.broadcastToRoom(roomId, 'typing_indicator', { userId, isTyping }, { excludeUser: userId });
      
      return {
        success: true,
        data: { roomId, userId, isTyping }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  // === DAEMON INTEGRATION METHODS ===

  private async storeMessage(message: ChatMessage): Promise<void> {
    // Store via database daemon
    try {
      await this.sendDaemonMessage('database', 'chat_messages:insert', {
        table: 'chat_messages',
        data: message
      });
    } catch (error) {
      this.log(`‚ö†Ô∏è Database storage failed for message ${message.id}, using cache only`, 'warn');
    }
  }

  private async loadMessagesFromDatabase(roomId: string, limit: number, before?: string): Promise<ChatMessage[]> {
    try {
      const response = await this.sendDaemonMessage('database', 'chat_messages:select', {
        table: 'chat_messages',
        where: { roomId },
        orderBy: [{ field: 'timestamp', direction: 'DESC' }],
        limit
      });
      
      return response.success ? (response.data.rows || []) : [];
    } catch (error) {
      this.log(`‚ö†Ô∏è Failed to load messages from database: ${error}`, 'warn');
      return [];
    }
  }

  private async broadcastToRoom(roomId: string, eventType: string, data: any, options: { excludeUser?: string } = {}): Promise<void> {
    try {
      await this.sendDaemonMessage('router', 'broadcast', {
        channel: `chat_room_${roomId}`,
        event: eventType,
        data,
        excludeUser: options.excludeUser
      });
    } catch (error) {
      this.log(`‚ö†Ô∏è Router broadcast failed: ${error}`, 'warn');
    }
  }

  private async processAIResponse(userMessage: ChatMessage): Promise<void> {
    try {
      // Get conversation context
      const history = this.messageCache.get(userMessage.roomId) || [];
      const recentHistory = history.slice(-10); // Last 10 messages for context
      
      // Request AI response via Academy daemon
      const response = await this.sendDaemonMessage('academy', 'generate_response', {
        message: userMessage.content,
        context: recentHistory,
        roomId: userMessage.roomId,
        userId: userMessage.userId
      });
      
      if (response.success && response.data.reply) {
        // Create AI response message
        const aiMessage: ChatMessage = {
          id: this.generateMessageId(),
          content: response.data.reply,
          roomId: userMessage.roomId,
          userId: 'ai_assistant',
          type: 'assistant',
          timestamp: new Date().toISOString(),
          metadata: {
            replyTo: userMessage.id,
            model: response.data.model,
            persona: response.data.persona
          }
        };
        
        // Store and broadcast AI response
        await this.storeMessage(aiMessage);
        this.addToMessageCache(userMessage.roomId, aiMessage);
        await this.broadcastToRoom(userMessage.roomId, 'message_received', aiMessage);
      }
      
    } catch (error) {
      this.log(`‚ö†Ô∏è AI response processing failed: ${error}`, 'warn');
    }
  }

  // === HELPER METHODS ===

  private async initializeChatRooms(): Promise<void> {
    // Load default rooms or create them
    const defaultRooms = [
      { id: 'general', name: 'General Chat', description: 'General discussion' },
      { id: 'academy', name: 'Academy', description: 'AI training and development' },
      { id: 'debug', name: 'Debug', description: 'System debugging and testing' }
    ];
    
    for (const roomData of defaultRooms) {
      const room: ChatRoom = {
        ...roomData,
        users: new Map(),
        createdAt: new Date().toISOString(),
        metadata: {}
      };
      
      this.activeRooms.set(room.id, room);
    }
  }

  private setupDaemonEventListeners(): void {
    // Listen for relevant system events
    // This could include user status changes, system announcements, etc.
  }

  private async getUserInfo(userId: string): Promise<ChatUser> {
    // Get user info from user management system
    return {
      id: userId,
      name: userId, // Fallback to ID
      avatar: 'üë§',
      status: 'online',
      joinedAt: new Date().toISOString(),
      metadata: {}
    };
  }

  private addToMessageCache(roomId: string, message: ChatMessage): void {
    if (!this.messageCache.has(roomId)) {
      this.messageCache.set(roomId, []);
    }
    
    const messages = this.messageCache.get(roomId)!;
    messages.push(message);
    
    // Keep cache reasonable size
    if (messages.length > 1000) {
      messages.splice(0, messages.length - 1000);
    }
  }

  private generateMessageId(): string {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async sendDaemonMessage(daemonName: string, messageType: string, data: any): Promise<any> {
    // This would integrate with the actual daemon messaging system
    // For now, return a mock response
    return {
      success: true,
      data: {}
    };
  }
}