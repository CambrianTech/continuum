#!/usr/bin/env npx tsx

/**
 * Configuration Files Generator
 * 
 * Generates all configuration files from unified-config.json:
 * - tsconfig.json paths
 * - package.json imports
 * - jtag-paths.json 
 * - Import map for browser builds
 */

import * as fs from 'fs';
import * as path from 'path';

interface PathMapping {
  alias: string;
  relativePath: string;
  description: string;
  autoGenerated: boolean;
}

interface UnifiedConfig {
  projectName: string;
  version: string;
  pathMappings: Record<string, PathMapping>;
  structureGeneration: {
    directories: Record<string, any>;
  };
  generatedAt: string;
  description: string;
}

class ConfigFilesGenerator {
  private rootPath: string;
  private config: UnifiedConfig;

  constructor() {
    this.rootPath = process.cwd();
    this.config = {} as UnifiedConfig;
  }

  async generateAllConfigFiles(): Promise<void> {
    console.log('‚öôÔ∏è  Configuration Files Generator');
    console.log('================================');
    console.log(`üìç Root path: ${this.rootPath}`);

    // Step 1: Load unified config
    await this.loadUnifiedConfig();

    // Step 2: Generate all config files
    await this.generateTsConfigPaths();
    await this.generatePackageJsonImports();
    await this.generateJtagPaths();
    await this.generateImportMap();

    console.log('\nüéâ All configuration files generated!');
  }

  private async loadUnifiedConfig(): Promise<void> {
    const configPath = path.join(this.rootPath, 'unified-config.json');
    
    try {
      const configContent = await fs.promises.readFile(configPath, 'utf8');
      this.config = JSON.parse(configContent);
      console.log(`\nüìÇ Loaded unified config with ${Object.keys(this.config.pathMappings).length} path mappings`);
    } catch (error) {
      throw new Error(`Failed to load unified config: ${error.message}`);
    }
  }

  private async generateTsConfigPaths(): Promise<void> {
    console.log('\nüîß Generating tsconfig.json paths...');

    const tsconfigPath = path.join(this.rootPath, 'tsconfig.json');
    let tsconfig: any;

    try {
      const content = await fs.promises.readFile(tsconfigPath, 'utf8');
      tsconfig = JSON.parse(content);
    } catch (error) {
      throw new Error(`Failed to read tsconfig.json: ${error.message}`);
    }

    // Generate paths from unified config
    const paths: Record<string, string[]> = {};

    for (const [alias, mapping] of Object.entries(this.config.pathMappings)) {
      // Skip dist/ paths for TypeScript compilation
      if (!mapping.relativePath.startsWith('dist/')) {
        paths[alias] = [mapping.relativePath];
        paths[`${alias}/*`] = [`${mapping.relativePath}/*`];
      }
    }

    // Update tsconfig with generated paths
    if (!tsconfig.compilerOptions) {
      tsconfig.compilerOptions = {};
    }
    tsconfig.compilerOptions.paths = paths;

    // Add generation timestamp comment
    tsconfig._generated = {
      timestamp: new Date().toISOString(),
      source: 'unified-config.json',
      pathCount: Object.keys(paths).length
    };

    await fs.promises.writeFile(tsconfigPath, JSON.stringify(tsconfig, null, 2), 'utf8');
    console.log(`   ‚úÖ Updated tsconfig.json with ${Object.keys(paths).length} path mappings`);
  }

  private async generatePackageJsonImports(): Promise<void> {
    console.log('\nüì¶ Generating package.json imports...');

    const packagePath = path.join(this.rootPath, 'package.json');
    let packageJson: any;

    try {
      const content = await fs.promises.readFile(packagePath, 'utf8');
      packageJson = JSON.parse(content);
    } catch (error) {
      throw new Error(`Failed to read package.json: ${error.message}`);
    }

    // Generate imports from unified config
    const imports: Record<string, string> = {};

    for (const [alias, mapping] of Object.entries(this.config.pathMappings)) {
      // For package.json imports, we need dist/ paths and .js extensions
      const distPath = mapping.relativePath.startsWith('dist/') 
        ? mapping.relativePath 
        : `dist/${mapping.relativePath}`;
      
      imports[alias] = `./${distPath}.js`;
      imports[`${alias}/*`] = `./${distPath}/*`;
    }

    // Update package.json with generated imports
    packageJson.imports = imports;

    // Add generation metadata
    packageJson._importGeneration = {
      timestamp: new Date().toISOString(),
      source: 'unified-config.json', 
      importCount: Object.keys(imports).length
    };

    await fs.promises.writeFile(packagePath, JSON.stringify(packageJson, null, 2), 'utf8');
    console.log(`   ‚úÖ Updated package.json with ${Object.keys(imports).length} import mappings`);
  }

  private async generateJtagPaths(): Promise<void> {
    console.log('\nüõ§Ô∏è  Generating jtag-paths.json...');

    const jtagPathsPath = path.join(this.rootPath, 'jtag-paths.json');

    // Generate pathMappings from unified config
    const pathMappings: Record<string, string> = {};

    for (const [alias, mapping] of Object.entries(this.config.pathMappings)) {
      // Skip dist/ paths for jtag-paths.json
      if (!mapping.relativePath.startsWith('dist/')) {
        pathMappings[alias] = mapping.relativePath;
      }
    }

    const jtagPaths = {
      pathMappings,
      description: "Auto-generated JTAG TypeScript path mappings from unified-config.json",
      _generated: {
        timestamp: new Date().toISOString(),
        source: 'unified-config.json',
        mappingCount: Object.keys(pathMappings).length
      }
    };

    await fs.promises.writeFile(jtagPathsPath, JSON.stringify(jtagPaths, null, 2), 'utf8');
    console.log(`   ‚úÖ Generated jtag-paths.json with ${Object.keys(pathMappings).length} path mappings`);
  }

  private async generateImportMap(): Promise<void> {
    console.log('\nüó∫Ô∏è  Generating import map for browser builds...');

    const importMapPath = path.join(this.rootPath, 'import-map.json');

    // Generate import map from unified config
    const importMap: Record<string, string> = {};

    for (const [alias, mapping] of Object.entries(this.config.pathMappings)) {
      // Skip dist/ paths, use relative paths for browser
      if (!mapping.relativePath.startsWith('dist/')) {
        importMap[alias] = `./${mapping.relativePath}`;
      }
    }

    const importMapConfig = {
      imports: importMap,
      description: "Auto-generated import map for browser builds from unified-config.json",
      _generated: {
        timestamp: new Date().toISOString(),
        source: 'unified-config.json',
        importCount: Object.keys(importMap).length
      }
    };

    await fs.promises.writeFile(importMapPath, JSON.stringify(importMapConfig, null, 2), 'utf8');
    console.log(`   ‚úÖ Generated import-map.json with ${Object.keys(importMap).length} import mappings`);
  }
}

// Run the generator
async function main() {
  try {
    const generator = new ConfigFilesGenerator();
    await generator.generateAllConfigFiles();
  } catch (error) {
    console.error('‚ùå Error generating config files:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { ConfigFilesGenerator };