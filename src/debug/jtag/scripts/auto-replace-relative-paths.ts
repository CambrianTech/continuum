#!/usr/bin/env npx tsx

/**
 * Automatic Relative Path Replacement Script
 * 
 * Clean, modular system for converting ugly relative paths to clean aliases.
 * Transforms "../../../../../../shared/JTAGTypes" ‚Üí "@shared/JTAGTypes"
 */

import * as fs from 'fs';
import * as path from 'path';

// ============================================================================
// Types & Interfaces
// ============================================================================

interface PathMapping {
  alias: string;
  relativePath: string;
  description: string;
  autoGenerated: boolean;
}

interface UnifiedConfig {
  pathMappings: { [key: string]: PathMapping };
}

interface ReplacementResult {
  originalPath: string;
  aliasPath: string;
  success: boolean;
}

interface ProcessingStats {
  filesProcessed: number;
  filesModified: number;
  totalReplacements: number;
}

// ============================================================================
// Configuration Loader - Single Responsibility
// ============================================================================

class ConfigurationLoader {
  private rootPath: string;

  constructor(rootPath: string) {
    this.rootPath = rootPath;
  }

  async loadPathMappings(): Promise<{ [key: string]: PathMapping }> {
    const configPath = path.join(this.rootPath, 'unified-config.json');
    
    try {
      const configContent = await fs.promises.readFile(configPath, 'utf-8');
      const config: UnifiedConfig = JSON.parse(configContent);
      return config.pathMappings;
    } catch (error) {
      throw new Error(`Failed to load unified-config.json: ${error}`);
    }
  }
}

// ============================================================================
// File Discovery Service - Single Responsibility
// ============================================================================

class FileDiscoveryService {
  private rootPath: string;
  private excludedDirs = new Set(['.git', 'node_modules', 'dist', 'examples']);
  private excludedPatterns = ['.bak'];

  constructor(rootPath: string) {
    this.rootPath = rootPath;
  }

  async findTypeScriptFiles(): Promise<string[]> {
    const files: string[] = [];
    await this.traverseDirectory('', files);
    return files;
  }

  private async traverseDirectory(currentPath: string, files: string[]): Promise<void> {
    try {
      const fullPath = path.resolve(this.rootPath, currentPath);
      const items = await fs.promises.readdir(fullPath, { withFileTypes: true });
      
      for (const item of items) {
        const itemPath = currentPath ? `${currentPath}/${item.name}` : item.name;
        
        if (item.isDirectory()) {
          if (this.shouldProcessDirectory(item.name)) {
            await this.traverseDirectory(itemPath, files);
          }
        } else if (this.isTargetFile(item.name)) {
          files.push(itemPath);
        }
      }
    } catch (error) {
      // Skip directories we can't read - no logging to keep it clean
    }
  }

  private shouldProcessDirectory(dirName: string): boolean {
    return !dirName.startsWith('.') && 
           !this.excludedDirs.has(dirName) &&
           !this.excludedPatterns.some(pattern => dirName.includes(pattern));
  }

  private isTargetFile(fileName: string): boolean {
    return fileName.endsWith('.ts') && !fileName.endsWith('.d.ts');
  }
}

// ============================================================================
// Path Resolution Engine - Single Responsibility  
// ============================================================================

class PathResolutionEngine {
  private rootPath: string;
  private aliasMappings: Map<string, string> = new Map();
  private pathMappings: { [key: string]: PathMapping };

  constructor(rootPath: string, pathMappings: { [key: string]: PathMapping }) {
    this.rootPath = rootPath;
    this.pathMappings = pathMappings;
    this.buildAliasMappings();
  }

  private buildAliasMappings(): void {
    Object.entries(this.pathMappings).forEach(([alias, mapping]) => {
      this.aliasMappings.set(mapping.relativePath, alias);
    });
  }

  resolveRelativePathToAlias(relativePath: string, currentFilePath: string): string | null {
    // Only process relative paths
    if (!relativePath.startsWith('.')) {
      return null;
    }

    // Convert relative path to absolute, then back to project-relative
    const currentDir = path.dirname(currentFilePath);
    const resolvedPath = path.resolve(currentDir, relativePath);
    const relativeFromRoot = path.relative(this.rootPath, resolvedPath);
    const normalizedPath = relativeFromRoot.replace(/\\/g, '/');
    
    return this.findBestMatchingAlias(normalizedPath);
  }

  private findBestMatchingAlias(targetPath: string): string | null {
    // Exact match first
    if (this.aliasMappings.has(targetPath)) {
      return this.aliasMappings.get(targetPath)!;
    }

    // Find longest matching prefix
    let bestMatch: { alias: string; pathLength: number } | null = null;

    for (const [mappingPath, alias] of this.aliasMappings.entries()) {
      if (targetPath.startsWith(mappingPath)) {
        if (!bestMatch || mappingPath.length > bestMatch.pathLength) {
          bestMatch = { alias, pathLength: mappingPath.length };
        }
      }
    }

    if (bestMatch) {
      return this.constructAliasPath(targetPath, bestMatch.alias);
    }

    return null;
  }

  private constructAliasPath(targetPath: string, alias: string): string {
    const mappingPath = Object.entries(this.pathMappings)
      .find(([a]) => a === alias)?.[1].relativePath;
    
    if (mappingPath && targetPath.length > mappingPath.length) {
      const remainingPath = targetPath.substring(mappingPath.length + 1);
      return `${alias}/${remainingPath}`;
    }
    
    return alias;
  }
}

// ============================================================================
// Import Statement Processor - Single Responsibility
// ============================================================================

class ImportStatementProcessor {
  private static readonly IMPORT_REGEX = /from\s+['"]([^'"]+)['"]/g;

  constructor(private pathResolver: PathResolutionEngine) {}

  processFileContent(content: string, filePath: string): { content: string; replacements: ReplacementResult[] } {
    const replacements: ReplacementResult[] = [];
    
    const updatedContent = content.replace(ImportStatementProcessor.IMPORT_REGEX, (match, importPath) => {
      const alias = this.pathResolver.resolveRelativePathToAlias(importPath, filePath);
      
      if (alias) {
        replacements.push({
          originalPath: importPath,
          aliasPath: alias,
          success: true
        });
        return match.replace(importPath, alias);
      }
      
      return match;
    });

    return { content: updatedContent, replacements };
  }
}

// ============================================================================
// File Processor - Coordinates Processing
// ============================================================================

class FileProcessor {
  constructor(
    private rootPath: string,
    private importProcessor: ImportStatementProcessor
  ) {}

  async processFile(filePath: string): Promise<{ modified: boolean; replacements: number }> {
    const fullPath = path.resolve(this.rootPath, filePath);
    
    try {
      const originalContent = await fs.promises.readFile(fullPath, 'utf-8');
      const { content: updatedContent, replacements } = this.importProcessor.processFileContent(originalContent, filePath);
      
      const wasModified = originalContent !== updatedContent;
      
      if (wasModified) {
        await fs.promises.writeFile(fullPath, updatedContent, 'utf-8');
      }
      
      return { modified: wasModified, replacements: replacements.length };
    } catch (error) {
      throw new Error(`Failed to process ${filePath}: ${error}`);
    }
  }
}

// ============================================================================
// Main Orchestrator - Coordinates All Services
// ============================================================================

class RelativePathReplacer {
  private stats: ProcessingStats = {
    filesProcessed: 0,
    filesModified: 0,
    totalReplacements: 0
  };

  constructor(private rootPath: string = process.cwd()) {}

  async run(): Promise<ProcessingStats> {
    console.log('üîÑ Automatic Relative Path Replacement');
    console.log('====================================');
    console.log(`üìç Root path: ${this.rootPath}\n`);

    // Initialize services
    const configLoader = new ConfigurationLoader(this.rootPath);
    const fileDiscovery = new FileDiscoveryService(this.rootPath);
    
    // Load configuration
    const pathMappings = await configLoader.loadPathMappings();
    console.log(`üìÇ Loaded ${Object.keys(pathMappings).length} path mappings`);
    
    // Initialize processing components
    const pathResolver = new PathResolutionEngine(this.rootPath, pathMappings);
    const importProcessor = new ImportStatementProcessor(pathResolver);
    const fileProcessor = new FileProcessor(this.rootPath, importProcessor);
    
    // Discover files
    const tsFiles = await fileDiscovery.findTypeScriptFiles();
    console.log(`üîç Found ${tsFiles.length} TypeScript files to scan\n`);
    
    // Process all files
    for (const filePath of tsFiles) {
      await this.processFile(filePath, fileProcessor);
    }
    
    this.printSummary();
    return this.stats;
  }

  private async processFile(filePath: string, processor: FileProcessor): Promise<void> {
    try {
      const result = await processor.processFile(filePath);
      
      this.stats.filesProcessed++;
      
      if (result.modified) {
        this.stats.filesModified++;
        this.stats.totalReplacements += result.replacements;
        console.log(`‚úÖ ${filePath}: ${result.replacements} replacements`);
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Could not process ${filePath}: ${error}`);
    }
  }

  private printSummary(): void {
    console.log('\nüìä Processing Summary');
    console.log('===================');
    console.log(`Files processed: ${this.stats.filesProcessed}`);
    console.log(`Files modified: ${this.stats.filesModified}`);
    console.log(`Total replacements: ${this.stats.totalReplacements}`);
    console.log('\nüéâ Relative path replacement complete!');
  }
}

// ============================================================================
// Entry Point
// ============================================================================

async function main(): Promise<void> {
  try {
    const replacer = new RelativePathReplacer();
    await replacer.run();
  } catch (error) {
    console.error('‚ùå Error:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

// ============================================================================
// Export for Integration
// ============================================================================

export { RelativePathReplacer };