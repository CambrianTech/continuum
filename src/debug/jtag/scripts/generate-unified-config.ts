#!/usr/bin/env npx tsx

/**
 * Unified Configuration Generator
 * 
 * Generates single source of truth for all path mappings by:
 * 1. Scanning actual directory structure
 * 2. Creating consistent naming convention
 * 3. Generating all config files from unified source
 */

import * as fs from 'fs';
import * as path from 'path';

interface PathMapping {
  alias: string;
  relativePath: string;
  description: string;
  autoGenerated: boolean;
}

interface UnifiedConfig {
  projectName: string;
  version: string;
  pathMappings: Record<string, PathMapping>;
  structureGeneration: {
    directories: Record<string, any>;
  };
  generatedAt: string;
  description: string;
}

class UnifiedConfigGenerator {
  private rootPath: string;
  private config: UnifiedConfig;
  
  constructor() {
    this.rootPath = process.cwd();
    this.config = {
      projectName: "@continuum/jtag",
      version: "1.0.291",
      pathMappings: {},
      structureGeneration: {
        directories: {}
      },
      generatedAt: new Date().toISOString(),
      description: "Auto-generated unified configuration for JTAG path mappings and structure generation"
    };
  }

  async generateConfig(): Promise<void> {
    console.log('üè≠ Unified Configuration Generator');
    console.log('================================');
    console.log(`üìç Root path: ${this.rootPath}`);
    
    // Step 1: Discover directory structure
    await this.discoverDirectoryStructure();
    
    // Step 2: Generate path mappings using existing naming patterns
    this.generatePathMappings();
    
    // Step 3: Generate structure generation config
    this.generateStructureConfig();
    
    // Step 4: Save unified config
    await this.saveUnifiedConfig();
    
    console.log('üéâ Unified configuration generated!');
  }

  private async discoverDirectoryStructure(): Promise<void> {
    console.log('\nüîç Discovering directory structure...');
    
    // Discover directories recursively
    const allDirs = await this.findAllDirectories('.');
    
    console.log(`   Found ${allDirs.length} total directories`);
    
    // Filter for directories that contain package.json with "type": "module"
    const relevantDirs: string[] = [];
    for (const dir of allDirs) {
      if (await this.isModuleDirectory(dir)) {
        relevantDirs.push(dir);
      }
    }
    
    console.log(`   ${relevantDirs.length} relevant module directories for path mappings`);
    
    for (const dir of relevantDirs) {
      this.addPathMapping(dir);
    }
  }

  private async findAllDirectories(startPath: string): Promise<string[]> {
    const directories: string[] = [];
    
    const traverse = async (currentPath: string): Promise<void> => {
      try {
        const fullPath = path.join(this.rootPath, currentPath);
        const items = await fs.promises.readdir(fullPath, { withFileTypes: true });
        
        for (const item of items) {
          if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
            const relativePath = currentPath === '.' ? item.name : path.join(currentPath, item.name);
            directories.push(relativePath);
            
            // Recurse into subdirectories
            await traverse(relativePath);
          }
        }
      } catch (error) {
        // Skip inaccessible directories
      }
    };
    
    await traverse(startPath);
    return directories;
  }

  private async isModuleDirectory(dirPath: string): Promise<boolean> {
    // Skip node_modules, dist, and hidden directories
    if (dirPath.includes('node_modules') || dirPath.startsWith('.') || dirPath.startsWith('dist/')) {
      return false;
    }
    
    // Include directories that would logically need path mappings:
    // 1. Root level structural directories
    if (['shared', 'browser', 'server', 'transports', 'tests'].includes(dirPath)) {
      return true;
    }
    
    // 2. Daemon directories (all levels)
    if (dirPath.startsWith('daemons/') && !dirPath.includes('.bak')) {
      return true;
    }
    
    // 3. Command directories (all levels) 
    if (dirPath.startsWith('commands/') && !dirPath.includes('.bak')) {
      return true;
    }
    
    // 4. Essential shared directories at any level
    if (dirPath.endsWith('/shared') && !dirPath.includes('.bak')) {
      return true;
    }
    
    // 5. Browser/server environment directories
    if ((dirPath.endsWith('/browser') || dirPath.endsWith('/server')) && !dirPath.includes('.bak')) {
      return true;
    }
    
    // 6. Special routing/queuing/events directories
    if (dirPath.startsWith('shared/') && ['routing', 'queuing', 'events'].includes(dirPath.split('/')[1])) {
      return true;
    }
    
    return false;
  }

  private addPathMapping(relativePath: string): void {
    // Generate alias using existing naming convention patterns
    const alias = this.generateAlias(relativePath);
    
    this.config.pathMappings[alias] = {
      alias,
      relativePath,
      description: `Auto-generated mapping for ${relativePath}`,
      autoGenerated: true
    };
  }

  private generateAlias(relativePath: string): string {
    // Apply existing naming convention patterns from current configs
    
    // Root level mappings
    if (relativePath === 'shared') return '@shared';
    if (relativePath === 'browser') return '@browser';
    if (relativePath === 'server') return '@server';
    if (relativePath === 'transports') return '@transports';
    if (relativePath === 'tests/shared') return '@testsShared';
    
    // Daemon root mappings
    if (relativePath === 'daemons') return '@daemonsRoot';
    if (relativePath.startsWith('daemons/') && !relativePath.includes('/')) {
      const daemonName = relativePath.replace('daemons/', '');
      return `@${daemonName.replace('-daemon', 'Daemon')}`;
    }
    
    // Daemon environment mappings
    if (relativePath.match(/^daemons\/[^\/]+\/(shared|browser|server)$/)) {
      const parts = relativePath.split('/');
      const daemonName = parts[1].replace('-daemon', 'Daemon');
      const env = parts[2];
      if (env === 'shared') return `@${daemonName.replace('Daemon', 'Shared')}`;
      return `@${daemonName}${env.charAt(0).toUpperCase() + env.slice(1)}`;
    }
    
    // Commands root
    if (relativePath === 'commands') return '@commandsRoot';
    
    // Command mappings
    if (relativePath.startsWith('commands/') && !relativePath.includes('/shared') && !relativePath.includes('/browser') && !relativePath.includes('/server')) {
      const commandPath = relativePath.replace('commands/', '');
      return `@${this.toCamelCase(commandPath)}Root`;
    }
    
    // Command environment mappings  
    if (relativePath.match(/^commands\/[^\/]+\/(shared|browser|server)$/)) {
      const parts = relativePath.split('/');
      const commandName = this.toCamelCase(parts[1]);
      const env = parts[2];
      return `@${commandName}${env.charAt(0).toUpperCase() + env.slice(1)}`;
    }
    
    // Nested command environment mappings
    if (relativePath.match(/^commands\/[^\/]+\/[^\/]+\/(shared|browser|server)$/)) {
      const parts = relativePath.split('/');
      const commandPath = `${parts[1]}/${parts[2]}`;
      const env = parts[3];
      return `@${this.toCamelCase(commandPath)}${env.charAt(0).toUpperCase() + env.slice(1)}`;
    }
    
    // Special cases from existing config that are critical for build system
    if (relativePath === 'daemons/command-daemon/shared/CommandBase') return '@commandBase';
    if (relativePath === 'shared/routing') return '@sharedRouting';
    if (relativePath === 'shared/queuing') return '@sharedQueuing';
    if (relativePath === 'shared/events') return '@sharedEvents';
    
    // Fallback: generate from path
    return `@${this.toCamelCase(relativePath)}`;
  }

  private toCamelCase(str: string): string {
    return str
      .replace(/[-_]/g, ' ')
      .replace(/\//g, ' ')
      .split(' ')
      .map((word, index) => 
        index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1)
      )
      .join('');
  }

  private generatePathMappings(): void {
    // Add critical special mappings that aren't directories but are needed for build system
    this.addSpecialMappings();
    
    console.log('\nüìã Generated path mappings:');
    
    // Sort by alias for consistent output
    const sortedAliases = Object.keys(this.config.pathMappings).sort();
    
    for (const alias of sortedAliases) {
      const mapping = this.config.pathMappings[alias];
      console.log(`   ${alias} ‚Üí ${mapping.relativePath}`);
    }
    
    console.log(`\n‚úÖ Total mappings: ${sortedAliases.length}`);
  }

  private addSpecialMappings(): void {
    // Add @commandBase which maps to a specific file, not a directory
    this.config.pathMappings['@commandBase'] = {
      alias: '@commandBase',
      relativePath: 'daemons/command-daemon/shared/CommandBase',
      description: 'Special mapping for CommandBase file (not directory)',
      autoGenerated: true
    };
  }

  private generateStructureConfig(): void {
    // Copy existing structure generation config from package.json
    this.config.structureGeneration = {
      directories: {
        browser: {
          outputFile: "browser/structure.ts",
          environment: "browser",
          daemonPaths: ["daemons/*/browser/*Browser.ts"],
          excludePatterns: ["**/*.bak", "**/*.bak/**/*", "**/node_modules/**/*"]
        },
        server: {
          outputFile: "server/structure.ts", 
          environment: "server",
          daemonPaths: ["daemons/*/server/*Server.ts"],
          excludePatterns: ["**/*.bak", "**/*.bak/**/*", "**/node_modules/**/*"]
        },
        "command-daemon-browser": {
          outputFile: "daemons/command-daemon/browser/structure.ts",
          environment: "browser",
          commandPaths: [
            "commands/*/browser/*BrowserCommand.ts",
            "commands/*/*/browser/*BrowserCommand.ts"
          ],
          excludePatterns: ["**/*.bak", "**/*.bak/**/*", "**/node_modules/**/*"]
        },
        "command-daemon-server": {
          outputFile: "daemons/command-daemon/server/structure.ts",
          environment: "server", 
          commandPaths: [
            "commands/*/server/*ServerCommand.ts",
            "commands/*/*/server/*ServerCommand.ts"
          ],
          excludePatterns: ["**/*.bak", "**/*.bak/**/*", "**/node_modules/**/*"]
        }
      }
    };
  }

  private async saveUnifiedConfig(): Promise<void> {
    const configPath = path.join(this.rootPath, 'unified-config.json');
    
    await fs.promises.writeFile(
      configPath,
      JSON.stringify(this.config, null, 2),
      'utf8'
    );
    
    console.log(`\nüíæ Saved unified config to: ${configPath}`);
  }
}

// Run the generator
async function main() {
  try {
    const generator = new UnifiedConfigGenerator();
    await generator.generateConfig();
  } catch (error) {
    console.error('‚ùå Error generating unified config:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { UnifiedConfigGenerator };