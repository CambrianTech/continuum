#!/usr/bin/env npx tsx

/**
 * Master Configuration Update Script
 * 
 * Single command to regenerate all configuration files from directory structure:
 * 1. Scans directory structure and generates unified-config.json
 * 2. Updates all config files (tsconfig.json, package.json, jtag-paths.json, import-map.json)
 */

import * as fs from 'fs';
import * as path from 'path';

interface PathMapping {
  alias: string;
  relativePath: string;
  description: string;
  autoGenerated: boolean;
}

interface UnifiedConfig {
  projectName: string;
  version: string;
  pathMappings: { [key: string]: PathMapping };
  structureGeneration: any;
  generatedAt: string;
  description: string;
}

class UnifiedConfigGenerator {
  private rootPath: string;

  constructor() {
    this.rootPath = process.cwd();
  }

  async generateConfig(): Promise<void> {
    console.log('üè≠ Unified Configuration Generator');
    console.log('================================');
    console.log(`üìç Root path: ${this.rootPath}\n`);

    console.log('üîç Discovering directory structure...');
    const directories = await this.findAllDirectories(this.rootPath);
    const relevantDirs = this.filterRelevantDirectories(directories);
    
    console.log(`   Found ${directories.length} total directories`);
    console.log(`   ${relevantDirs.length} relevant module directories for path mappings\n`);

    const pathMappings = this.generatePathMappings(relevantDirs);
    
    console.log('üìã Generated path mappings:');
    Object.entries(pathMappings).forEach(([alias, mapping]) => {
      console.log(`   ${alias} ‚Üí ${mapping.relativePath}`);
    });
    console.log(`\n‚úÖ Total mappings: ${Object.keys(pathMappings).length}\n`);

    const config = this.createUnifiedConfig(pathMappings);
    await this.saveConfig(config);
    
    console.log('üéâ Unified configuration generated!\n');
  }

  private async findAllDirectories(startPath: string): Promise<string[]> {
    const directories: string[] = [];
    
    const traverse = async (currentPath: string): Promise<void> => {
      try {
        const fullPath = path.resolve(this.rootPath, currentPath);
        const items = await fs.promises.readdir(fullPath, { withFileTypes: true });
        
        for (const item of items) {
          if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
            const relativePath = currentPath ? `${currentPath}/${item.name}` : item.name;
            directories.push(relativePath);
            await traverse(relativePath);
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };

    await traverse('');
    return directories;
  }

  private filterRelevantDirectories(directories: string[]): string[] {
    return directories.filter(dir => {
      const parts = dir.split('/');
      
      // Skip deep nested or irrelevant paths
      if (parts.length > 4) return false;
      if (parts.some(part => ['dist', 'node_modules', '.git', 'examples', 'mcp'].includes(part))) return false;
      if (dir.includes('.bak')) return false;
      
      // Skip browser, server, and shared subdirectories - they shouldn't have their own aliases
      const lastPart = parts[parts.length - 1];
      if (['browser', 'server', 'shared'].includes(lastPart)) return false;
      
      return true;
    });
  }

  private generatePathMappings(directories: string[]): { [key: string]: PathMapping } {
    const mappings: { [key: string]: PathMapping } = {};
    const aliasToDirectories: { [key: string]: string[] } = {};
    
    directories.forEach(dir => {
      const alias = this.generateAlias(dir);
      
      // Track aliases and their source directories for conflict detection
      if (!aliasToDirectories[alias]) {
        aliasToDirectories[alias] = [];
      }
      aliasToDirectories[alias].push(dir);
      
      mappings[alias] = {
        alias,
        relativePath: dir,
        description: `Auto-generated mapping for ${dir}`,
        autoGenerated: true
      };
    });

    // Check for duplicate aliases and report conflicts
    const duplicates = Object.entries(aliasToDirectories).filter(([alias, dirs]) => dirs.length > 1);
    if (duplicates.length > 0) {
      console.error('\n‚ùå DUPLICATE ALIAS CONFLICTS DETECTED:');
      console.error('=====================================');
      duplicates.forEach(([alias, dirs]) => {
        console.error(`üî¥ Alias "${alias}" conflicts:`);
        dirs.forEach((dir, index) => {
          console.error(`   ${index + 1}. ${dir}`);
        });
        console.error('');
      });
      
      console.error('üí° RESOLUTION STRATEGIES:');
      console.error('   ‚Ä¢ Rename one of the conflicting directories');
      console.error('   ‚Ä¢ Adjust alias generation logic in generateAlias()');
      console.error('   ‚Ä¢ Use more specific path parts for disambiguation');
      console.error('');
      
      throw new Error(`Found ${duplicates.length} alias conflicts. Fix directory naming or alias generation logic.`);
    }

    // Add special mappings for individual files with conflict detection
    const specialMappings = [
      {
        alias: '@commandBase',
        relativePath: 'daemons/command-daemon/shared/CommandBase',
        description: 'Special mapping for CommandBase file (not directory)'
      },
      {
        alias: '@shared',
        relativePath: 'shared',
        description: 'Essential mapping for shared directory root (critical for system architecture)'
      }
    ];

    specialMappings.forEach(special => {
      if (mappings[special.alias]) {
        console.error(`\n‚ùå SPECIAL MAPPING CONFLICT DETECTED:`);
        console.error(`üî¥ Special alias "${special.alias}" conflicts with auto-generated mapping:`);
        console.error(`   Auto-generated: ${mappings[special.alias].relativePath}`);
        console.error(`   Special mapping: ${special.relativePath}`);
        console.error('');
        throw new Error(`Special mapping "${special.alias}" conflicts with auto-generated alias. Rename conflicting directory or adjust alias generation.`);
      }
      
      mappings[special.alias] = {
        alias: special.alias,
        relativePath: special.relativePath,
        description: special.description,
        autoGenerated: true  
      };
    });

    return mappings;
  }

  private generateAlias(dirPath: string): string {
    const parts = dirPath.split('/');
    
    // Use only the last two parts (or just one if there's only one)
    const relevantParts = parts.length === 1 ? [parts[0]] : parts.slice(-2);
    
    const camelCase = relevantParts.map((part, index) => {
      if (index === 0) return part;
      return part.charAt(0).toUpperCase() + part.slice(1).replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
    }).join('');
    
    return `@${camelCase}`;
  }

  private createUnifiedConfig(pathMappings: { [key: string]: PathMapping }): UnifiedConfig {
    const packageJson = JSON.parse(fs.readFileSync(path.join(this.rootPath, 'package.json'), 'utf-8'));
    
    return {
      projectName: packageJson.name ?? '@continuum/jtag',
      version: packageJson.version ?? '1.0.0',
      pathMappings,
      structureGeneration: {
        directories: {
          browser: {
            outputFile: 'browser/generated.ts',
            environment: 'browser',
            daemonPaths: ['daemons/*/browser/*Browser.ts'],
            commandPaths: [
              'commands/**/browser/*Command.ts',
            ],
            excludePatterns: ['**/*.bak', '**/*.bak/**/*', '**/node_modules/**/*']
          },
          server: {
            outputFile: 'server/generated.ts',
            environment: 'server', 
            daemonPaths: ['daemons/*/server/*Server.ts'],
            commandPaths: [
              'commands/**/server/*Command.ts',
            ],
            excludePatterns: ['**/*.bak', '**/*.bak/**/*', '**/node_modules/**/*']
          }
        }
      },
      generatedAt: new Date().toISOString(),
      description: 'Auto-generated unified configuration for JTAG path mappings and structure generation'
    };
  }

  private async saveConfig(config: UnifiedConfig): Promise<void> {
    const configPath = path.join(this.rootPath, 'unified-config.json');
    await fs.promises.writeFile(configPath, JSON.stringify(config, null, 2));
    console.log(`üíæ Saved unified config to: ${configPath}`);
  }
}

class ConfigFilesGenerator {
  private rootPath: string;
  private config: UnifiedConfig;

  constructor() {
    this.rootPath = process.cwd();
  }

  async generateAllConfigFiles(): Promise<void> {
    console.log('‚öôÔ∏è  Configuration Files Generator');
    console.log('================================');
    console.log(`üìç Root path: ${this.rootPath}\n`);

    await this.loadUnifiedConfig();
    
    console.log(`üìÇ Loaded unified config with ${Object.keys(this.config.pathMappings).length} path mappings\n`);

    await this.generateTsConfig();
    await this.generatePackageJsonImports(); 
    await this.generateJtagPaths();
    await this.generateImportMap();

    console.log('\nüéâ All configuration files generated!\n');
  }

  private async loadUnifiedConfig(): Promise<void> {
    const configPath = path.join(this.rootPath, 'unified-config.json');
    const configContent = await fs.promises.readFile(configPath, 'utf-8');
    this.config = JSON.parse(configContent);
  }

  private async generateTsConfig(): Promise<void> {
    console.log('üîß Generating tsconfig.json paths...');
    
    const tsconfigPath = path.join(this.rootPath, 'tsconfig.json');
    const tsconfig = JSON.parse(await fs.promises.readFile(tsconfigPath, 'utf-8'));
    
    const paths: { [key: string]: string[] } = {};
    
    Object.entries(this.config.pathMappings).forEach(([alias, mapping]) => {
      paths[alias] = [mapping.relativePath];
      paths[`${alias}/*`] = [`${mapping.relativePath}/*`];
    });

    tsconfig.compilerOptions.paths = paths;
    tsconfig._generated = {
      timestamp: new Date().toISOString(),
      source: 'unified-config.json',
      pathCount: Object.keys(paths).length
    };

    await fs.promises.writeFile(tsconfigPath, JSON.stringify(tsconfig, null, 2));
    console.log(`   ‚úÖ Updated tsconfig.json with ${Object.keys(paths).length} path mappings\n`);
  }

  private async generatePackageJsonImports(): Promise<void> {
    console.log('üì¶ Generating package.json imports...');
    
    const packagePath = path.join(this.rootPath, 'package.json');
    const packageJson = JSON.parse(await fs.promises.readFile(packagePath, 'utf-8'));
    
    const imports: { [key: string]: string } = {};
    
    Object.entries(this.config.pathMappings).forEach(([alias, mapping]) => {
      imports[`${alias}/*`] = `./dist/${mapping.relativePath}/*`;
      imports[alias] = `./dist/${mapping.relativePath}.js`;
    });

    packageJson.imports = imports;
    packageJson._importGeneration = {
      timestamp: new Date().toISOString(),
      source: 'unified-config.json',
      importCount: Object.keys(imports).length
    };

    await fs.promises.writeFile(packagePath, JSON.stringify(packageJson, null, 2));
    console.log(`   ‚úÖ Updated package.json with ${Object.keys(imports).length} import mappings\n`);
  }

  private async generateJtagPaths(): Promise<void> {
    console.log('üõ§Ô∏è  Generating jtag-paths.json...');
    
    const pathMappings: { [key: string]: string } = {};
    
    Object.entries(this.config.pathMappings).forEach(([alias, mapping]) => {
      pathMappings[alias] = mapping.relativePath;
    });

    const jtagPaths = {
      pathMappings,
      description: 'Auto-generated JTAG TypeScript path mappings from unified-config.json',
      _generated: {
        timestamp: new Date().toISOString(),
        source: 'unified-config.json',
        mappingCount: Object.keys(pathMappings).length
      }
    };

    const jtagPathsPath = path.join(this.rootPath, 'jtag-paths.json');
    await fs.promises.writeFile(jtagPathsPath, JSON.stringify(jtagPaths, null, 2));
    console.log(`   ‚úÖ Generated jtag-paths.json with ${Object.keys(pathMappings).length} path mappings\n`);
  }

  private async generateImportMap(): Promise<void> {
    console.log('üó∫Ô∏è  Generating import map for browser builds...');
    
    const imports: { [key: string]: string } = {};
    
    Object.entries(this.config.pathMappings).forEach(([alias, mapping]) => {
      imports[alias] = `./${mapping.relativePath}`;
    });

    const importMap = {
      imports,
      description: 'Auto-generated import map for browser builds from unified-config.json',
      _generated: {
        timestamp: new Date().toISOString(),
        source: 'unified-config.json',
        importCount: Object.keys(imports).length
      }
    };

    const importMapPath = path.join(this.rootPath, 'import-map.json');
    await fs.promises.writeFile(importMapPath, JSON.stringify(importMap, null, 2));
    console.log(`   ‚úÖ Generated import-map.json with ${Object.keys(imports).length} import mappings\n`);
  }
}

async function main() {
  console.log('üöÄ Master Configuration Update');
  console.log('=============================');
  console.log('Updating all configurations from directory structure...\n');

  try {
    // Step 1: Generate unified config from directory structure
    console.log('Step 1: Scanning directory structure...');
    const unifiedGenerator = new UnifiedConfigGenerator();
    await unifiedGenerator.generateConfig();

    console.log('\n' + '='.repeat(50) + '\n');

    // Step 2: Generate all config files from unified config
    console.log('Step 2: Generating all configuration files...');
    const configGenerator = new ConfigFilesGenerator();
    await configGenerator.generateAllConfigFiles();

    console.log('\n' + 'üéâ'.repeat(20));
    console.log('‚úÖ All configurations updated successfully!');
    console.log('üìÅ Files updated:');
    console.log('   ‚Ä¢ unified-config.json (master source)');
    console.log('   ‚Ä¢ tsconfig.json (TypeScript paths)');
    console.log('   ‚Ä¢ package.json (import mappings)');
    console.log('   ‚Ä¢ jtag-paths.json (build system paths)');
    console.log('   ‚Ä¢ import-map.json (browser import map)');
    console.log('\nüí° Run this script whenever directory structure changes');

  } catch (error) {
    console.error('‚ùå Error updating configurations:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

// ============================================================================
// Export for Integration
// ============================================================================

export { UnifiedConfigGenerator, ConfigFilesGenerator };