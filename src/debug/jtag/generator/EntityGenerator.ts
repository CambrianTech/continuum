/**
 * EntityGenerator - Generates entity classes with decorators and validation
 *
 * Extends ModuleGenerator to create complete entity implementations:
 * - Entity class extending BaseEntity
 * - Field decorators (@TextField, @JsonField, @DateField, etc.)
 * - validate() method with type checking and constraints
 * - Collection property
 * - Constructor with default values
 *
 * Prevents orphaned schemas by generating proper entity backing code
 */

import * as path from 'path';
import { ModuleGenerator } from './ModuleGenerator';
import type { EntitySpec, EntityField, ValidationRule } from './EntityTypes';

export class EntityGenerator extends ModuleGenerator<EntitySpec> {
  private currentSpec?: EntitySpec;

  protected getModuleType(): string {
    return 'entity';
  }

  protected getModuleName(spec: EntitySpec): string {
    return spec.name;
  }

  protected getOutputDir(spec: EntitySpec): string {
    // Entities go in system/data/entities/
    return path.join(this.rootPath, 'system', 'data', 'entities');
  }

  protected renderTemplates(spec: EntitySpec): Record<string, string> {
    this.currentSpec = spec;

    return {
      entity: this.generateEntityClass(spec)
    };
  }

  protected writeFiles(baseDir: string, rendered: Record<string, string>): void {
    if (!this.currentSpec) {
      throw new Error('currentSpec not set - renderTemplates must be called first');
    }

    const className = this.currentSpec.name; // Already PascalCase from spec
    const filePath = path.join(baseDir, `${className}Entity.ts`);

    this.writeFile(filePath, rendered.entity);

    console.log(`\nðŸ’¡ Next steps:`);
    console.log(`   1. Register entity in EntityRegistry.ts:`);
    console.log(`      import { ${className}Entity } from '../../../system/data/entities/${className}Entity';`);
    console.log(`      new ${className}Entity();`);
    console.log(`      registerEntity(${className}Entity.collection, ${className}Entity);`);
    console.log(`   2. Schema will be created automatically on first data operation`);

    this.currentSpec = undefined;
  }

  /**
   * Generate complete entity class with decorators and validation
   */
  private generateEntityClass(spec: EntitySpec): string {
    const imports = this.generateImports(spec);
    const interfaces = this.generateInterfaces(spec);
    const classDeclaration = this.generateClassDeclaration(spec);
    const staticCollection = this.generateStaticCollection(spec);
    const fieldDeclarations = this.generateFieldDeclarations(spec);
    const constructor = this.generateConstructor(spec);
    const collectionGetter = this.generateCollectionGetter(spec);
    const validateMethod = this.generateValidateMethod(spec);

    return `/**
 * ${spec.name}Entity - ${spec.description}
 * Generated by EntityGenerator
 */

${imports}

${interfaces}${classDeclaration}
${staticCollection}

${fieldDeclarations}

  // Index signature for compatibility
  [key: string]: unknown;

${constructor}

${collectionGetter}

${validateMethod}
}
`;
  }

  /**
   * Generate import statements
   */
  private generateImports(spec: EntitySpec): string {
    const imports: string[] = [];

    // Always import UUID type
    imports.push(`import type { UUID } from '../../core/types/CrossPlatformUUID';`);

    // Determine which decorators are needed
    const decorators = new Set<string>();
    for (const field of Object.values(spec.fields)) {
      switch (field.type) {
        case 'string':
          decorators.add('TextField');
          break;
        case 'number':
          decorators.add('NumberField');
          break;
        case 'boolean':
          decorators.add('BooleanField');
          break;
        case 'UUID':
          decorators.add('TextField'); // UUIDs stored as text
          break;
        case 'Date':
          decorators.add('DateField');
          break;
        case 'JSON':
        case 'array':
          decorators.add('JsonField');
          break;
      }
    }

    // Add TEXT_LENGTH if any text fields have maxLength
    const hasMaxLength = Object.values(spec.fields).some(
      f => f.type === 'string' && f.validation?.maxLength
    );
    if (hasMaxLength) {
      decorators.add('TEXT_LENGTH');
    }

    if (decorators.size > 0) {
      imports.push(`import {
  ${Array.from(decorators).join(',\n  ')}
} from '../decorators/FieldDecorators';`);
    }

    // Import BaseEntity
    imports.push(`import { BaseEntity } from './BaseEntity';`);

    return imports.join('\n');
  }

  /**
   * Generate TypeScript interfaces for complex field types
   */
  private generateInterfaces(spec: EntitySpec): string {
    const interfaces: string[] = [];

    // Find JSON fields that might need type definitions
    for (const [fieldName, field] of Object.entries(spec.fields)) {
      if (field.type === 'JSON' && field.description.includes('interface')) {
        // Generate placeholder interface
        const interfaceName = this.fieldNameToInterfaceName(fieldName);
        interfaces.push(`
/**
 * ${field.description}
 */
export interface ${interfaceName} {
  // TODO: Add interface properties
}`);
      }
    }

    return interfaces.length > 0 ? interfaces.join('\n') + '\n' : '';
  }

  /**
   * Generate class declaration
   */
  private generateClassDeclaration(spec: EntitySpec): string {
    const extendsClass = spec.extends || 'BaseEntity';
    return `export class ${spec.name}Entity extends ${extendsClass} {`;
  }

  /**
   * Generate static collection property
   */
  private generateStaticCollection(spec: EntitySpec): string {
    return `  static readonly collection = '${spec.collectionName}';`;
  }

  /**
   * Generate field declarations with decorators
   */
  private generateFieldDeclarations(spec: EntitySpec): string {
    const fields: string[] = [];

    for (const [fieldName, field] of Object.entries(spec.fields)) {
      const decorator = this.generateFieldDecorator(field);
      const typeAnnotation = this.getTypeScriptType(field);
      const optionalMarker = field.optional ? '?' : '';

      fields.push(`  ${decorator}
  ${fieldName}${optionalMarker}: ${typeAnnotation};`);
    }

    return fields.join('\n\n');
  }

  /**
   * Generate field decorator based on field type
   */
  private generateFieldDecorator(field: EntityField): string {
    const options: string[] = [];

    // Add index option
    if (field.validation?.enum) {
      options.push('index: true'); // Index enum fields for filtering
    }

    // Add maxLength for text fields
    if (field.type === 'string' && field.validation?.maxLength) {
      if (field.validation.maxLength <= 200) {
        options.push('maxLength: TEXT_LENGTH.SHORT');
      } else if (field.validation.maxLength <= 1000) {
        options.push('maxLength: TEXT_LENGTH.MEDIUM');
      } else {
        options.push('maxLength: TEXT_LENGTH.LONG');
      }
    }

    const optionsStr = options.length > 0 ? `{ ${options.join(', ')} }` : '';

    switch (field.type) {
      case 'string':
      case 'UUID':
        return `@TextField(${optionsStr})`;
      case 'number':
        return `@NumberField(${optionsStr})`;
      case 'boolean':
        return `@BooleanField(${optionsStr})`;
      case 'Date':
        return `@DateField(${optionsStr})`;
      case 'JSON':
      case 'array':
        return `@JsonField(${optionsStr})`;
      default:
        return `@TextField(${optionsStr})`;
    }
  }

  /**
   * Get TypeScript type for field
   */
  private getTypeScriptType(field: EntityField): string {
    switch (field.type) {
      case 'string':
        return 'string';
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'UUID':
        return 'UUID';
      case 'Date':
        return 'Date';
      case 'array':
        return field.arrayItemType ? `${field.arrayItemType}[]` : 'any[]';
      case 'JSON':
        // Use Record<string, unknown> for generic JSON fields
        // (developer can refine to specific interface later)
        return 'Record<string, unknown>';
      default:
        return 'unknown';
    }
  }

  /**
   * Generate constructor with default values
   */
  private generateConstructor(spec: EntitySpec): string {
    const initializers: string[] = [];

    for (const [fieldName, field] of Object.entries(spec.fields)) {
      if (field.optional) continue; // Optional fields don't need initialization

      const defaultValue = this.getDefaultValue(field);
      initializers.push(`    this.${fieldName} = ${defaultValue};`);
    }

    return `  constructor() {
    super();

${initializers.join('\n')}
  }`;
  }

  /**
   * Get default value for field type
   */
  private getDefaultValue(field: EntityField): string {
    if (field.default !== undefined) {
      if (typeof field.default === 'string') {
        return `'${field.default}'`;
      }
      return String(field.default);
    }

    switch (field.type) {
      case 'string':
      case 'UUID':
        return "''";
      case 'number':
        return '0';
      case 'boolean':
        return 'false';
      case 'Date':
        return 'new Date()';
      case 'array':
        return '[]';
      case 'JSON':
        return '{}';
      default:
        return 'undefined';
    }
  }

  /**
   * Generate collection getter
   */
  private generateCollectionGetter(spec: EntitySpec): string {
    return `  get collection(): string {
    return ${spec.name}Entity.collection;
  }`;
  }

  /**
   * Generate validate() method with type checking and constraints
   */
  private generateValidateMethod(spec: EntitySpec): string {
    const validations: string[] = [];

    // Generate validation checks for each field
    for (const [fieldName, field] of Object.entries(spec.fields)) {
      if (field.optional) continue; // Optional fields can be missing

      const checks = this.generateFieldValidation(fieldName, field);
      validations.push(...checks);
    }

    const validationCode = validations.length > 0
      ? validations.join('\n\n')
      : '    // No validation rules defined';

    return `  /**
   * Validate ${spec.name.toLowerCase()} data
   */
  validate(): { success: boolean; error?: string } {
${validationCode}

    return { success: true };
  }`;
  }

  /**
   * Generate validation checks for a single field
   */
  private generateFieldValidation(fieldName: string, field: EntityField): string[] {
    const checks: string[] = [];

    // Required field check
    if (field.type === 'string' || field.type === 'UUID') {
      checks.push(`    if (!this.${fieldName}?.trim()) {
      return { success: false, error: '${field.description} is required' };
    }`);
    } else if (field.type !== 'boolean') { // booleans can be false
      checks.push(`    if (!this.${fieldName}) {
      return { success: false, error: '${field.description} is required' };
    }`);
    }

    // Type-specific validation
    const validation = field.validation;
    if (!validation) return checks;

    // String validation
    if (field.type === 'string') {
      if (validation.minLength) {
        checks.push(`    if (this.${fieldName}.length < ${validation.minLength}) {
      return { success: false, error: '${field.description} must be at least ${validation.minLength} characters' };
    }`);
      }

      if (validation.maxLength) {
        checks.push(`    if (this.${fieldName}.length > ${validation.maxLength}) {
      return { success: false, error: '${field.description} must be ${validation.maxLength} characters or less' };
    }`);
      }

      if (validation.pattern) {
        checks.push(`    if (!/${validation.pattern}/.test(this.${fieldName})) {
      return { success: false, error: '${validation.message || field.description + ' has invalid format'}' };
    }`);
      }
    }

    // Number validation
    if (field.type === 'number') {
      if (validation.min !== undefined) {
        checks.push(`    if (this.${fieldName} < ${validation.min}) {
      return { success: false, error: '${field.description} must be at least ${validation.min}' };
    }`);
      }

      if (validation.max !== undefined) {
        checks.push(`    if (this.${fieldName} > ${validation.max}) {
      return { success: false, error: '${field.description} must be at most ${validation.max}' };
    }`);
      }
    }

    // Enum validation
    if (validation.enum) {
      const enumValues = validation.enum.map(v => typeof v === 'string' ? `'${v}'` : v).join(', ');
      checks.push(`    if (![${enumValues}].includes(this.${fieldName})) {
      return { success: false, error: '${field.description} must be one of: ${validation.enum.join(', ')}' };
    }`);
    }

    // Array validation
    if (field.type === 'array') {
      checks.push(`    if (!Array.isArray(this.${fieldName})) {
      return { success: false, error: '${field.description} must be an array' };
    }`);
    }

    return checks;
  }

  /**
   * Convert field name to interface name
   * e.g., "metadata" -> "Metadata", "fitness" -> "Fitness"
   */
  private fieldNameToInterfaceName(fieldName: string): string {
    return fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
  }
}
