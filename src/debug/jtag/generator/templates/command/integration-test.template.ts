#!/usr/bin/env tsx
/**
 * {{CLASS_NAME}} Command Integration Tests
 *
 * Tests {{COMMAND_NAME}} command with real client connections and system integration.
 * Follows middle-out Layer 4 (System Integration) testing methodology.
 *
 * Generated by: ./jtag generate
 * Run with: npx tsx commands/{{COMMAND_NAME}}/test/integration/{{CLASS_NAME}}Integration.test.ts
 *
 * PREREQUISITES:
 * - Server must be running: npm start
 * - Wait 90+ seconds for deployment to complete
 * - Browser client must be connected
 */

import {
  testClientConnection,
  testClientCommandExecution,
  validateConnectionResult,
  assertConnectionResult
} from '../../../test/utils/ClientTestUtils';

import {
  validateCommandResult,
  testCommandWithTimeout,
  assertCommandResult
} from '../../../test/utils/CommandTestUtils';

import type { {{CLASS_NAME}}Params, {{CLASS_NAME}}Result } from '../../shared/{{CLASS_NAME}}Types';

console.log('üß™ {{CLASS_NAME}} Command Integration Tests');

function assert(condition: boolean, message: string) {
  if (!condition) {
    throw new Error(`‚ùå Assertion failed: ${message}`);
  }
  console.log(`‚úÖ ${message}`);
}

/**
 * Test 1: Client connection for {{COMMAND_NAME}} testing
 */
async function test{{CLASS_NAME}}ClientConnection() {
  console.log('\nüîå Test 1: Client connection for {{COMMAND_NAME}} testing');

  try {
    // Import the browser client (connects to existing server via WebSocket)
    const { jtag } = await import('../../../../browser-index');

    console.log('üîÑ Connecting to JTAG system...');
    const client = await jtag.connect();

    // Validate connection
    const connectionInfo = client.getConnectionInfo();

    assert(connectionInfo.environment === 'browser', 'Connected via browser client');
    assert(!connectionInfo.isBootstrapSession, 'Session properly assigned (not bootstrap)');

    console.log(`üìä Connection Details:`);
    console.log(`   Environment: ${connectionInfo.environment}`);
    console.log(`   Connection Type: ${connectionInfo.connectionType}`);
    console.log(`   Session ID: ${connectionInfo.sessionId}`);

    return { client };

  } catch (error) {
    console.error('‚ùå Client connection failed:', error.message);
    throw error;
  }
}

/**
 * Test 2: Real {{COMMAND_NAME}} command execution
 */
async function testReal{{CLASS_NAME}}Execution() {
  console.log('\n‚ö° Test 2: Real {{COMMAND_NAME}} command execution');

  try {
    const { jtag } = await import('../../../../browser-index');
    const client = await jtag.connect();

    console.log('üöÄ Executing {{COMMAND_NAME}} command...');

    // TODO: Test basic command execution
    // Example:
    // const { result: basicResult, executionTime: basicTime } = await testClientCommandExecution<{{CLASS_NAME}}Result>(
    //   client,
    //   '{{COMMAND_NAME}}',
    //   { requiredParam: 'test-value' },
    //   5000
    // );
    //
    // assert(validateCommandResult(basicResult, ['yourResultField']), 'Basic {{COMMAND_NAME}} has correct structure');
    // assert(basicResult.success === true, '{{CLASS_NAME}} succeeded');
    // console.log(`   {{CLASS_NAME}} execution: ${basicTime}ms`);

    console.log('‚ö†Ô∏è  TODO: Add real command execution test for {{COMMAND_NAME}}');

  } catch (error) {
    console.error('‚ùå Real {{COMMAND_NAME}} execution failed:', error.message);
    throw error;
  }
}

/**
 * Test 3: {{COMMAND_NAME}} with missing required parameters
 *
 * CRITICAL: This test ensures the live system properly handles
 * ValidationError when required parameters are missing
 */
async function test{{CLASS_NAME}}MissingParams() {
  console.log('\nüö® Test 3: {{COMMAND_NAME}} with missing required parameters');

  try {
    const { jtag } = await import('../../../../browser-index');
    const client = await jtag.connect();

    console.log('üîç Testing {{COMMAND_NAME}} without required parameters...');

    // TODO: Test missing required parameter throws ValidationError
    // Example:
    // try {
    //   await client.executeCommand('{{COMMAND_NAME}}', {});
    //   assert(false, 'Should have thrown ValidationError');
    // } catch (error) {
    //   assert(error.type === 'validation', 'Throws ValidationError');
    //   assert(error.message.includes('requiredParam'), 'Error mentions missing parameter');
    //   assert(error.message.includes('help tool'), 'Error message is tool-agnostic');
    //   console.log(`‚úÖ ValidationError thrown correctly: ${error.message}`);
    // }

    console.log('‚ö†Ô∏è  TODO: Add missing required params test for {{COMMAND_NAME}}');

  } catch (error) {
    console.error('‚ùå Missing params test failed:', error.message);
    throw error;
  }
}

/**
 * Test 4: {{COMMAND_NAME}} with optional parameters
 */
async function test{{CLASS_NAME}}OptionalParams() {
  console.log('\nüîß Test 4: {{COMMAND_NAME}} with optional parameters');

  try {
    const { jtag } = await import('../../../../browser-index');
    const client = await jtag.connect();

    // TODO: Test with optional parameters
    // Example:
    // const withOptional = await testClientCommandExecution<{{CLASS_NAME}}Result>(
    //   client,
    //   '{{COMMAND_NAME}}',
    //   { requiredParam: 'test', optionalParam: true },
    //   5000
    // );
    //
    // assert(withOptional.result.success === true, '{{CLASS_NAME}} succeeds with optional params');

    // TODO: Test without optional parameters (should use defaults)
    // const withoutOptional = await testClientCommandExecution<{{CLASS_NAME}}Result>(
    //   client,
    //   '{{COMMAND_NAME}}',
    //   { requiredParam: 'test' },
    //   5000
    // );
    //
    // assert(withoutOptional.result.success === true, '{{CLASS_NAME}} succeeds without optional params');

    console.log('‚ö†Ô∏è  TODO: Add optional params test for {{COMMAND_NAME}}');

  } catch (error) {
    console.error('‚ùå Optional params test failed:', error.message);
    throw error;
  }
}

/**
 * Test 5: {{COMMAND_NAME}} performance under load
 */
async function test{{CLASS_NAME}}Performance() {
  console.log('\n‚ö° Test 5: {{COMMAND_NAME}} performance under load');

  try {
    const { jtag } = await import('../../../../browser-index');
    const client = await jtag.connect();

    // TODO: Test command performance
    // Example:
    // const iterations = 10;
    // const executionTimes: number[] = [];
    //
    // for (let i = 0; i < iterations; i++) {
    //   const { executionTime } = await testClientCommandExecution<{{CLASS_NAME}}Result>(
    //     client,
    //     '{{COMMAND_NAME}}',
    //     { requiredParam: `test-${i}` },
    //     5000
    //   );
    //   executionTimes.push(executionTime);
    // }
    //
    // const avgTime = executionTimes.reduce((a, b) => a + b, 0) / iterations;
    // const maxTime = Math.max(...executionTimes);
    //
    // console.log(`   Average execution time: ${avgTime.toFixed(2)}ms`);
    // console.log(`   Max execution time: ${maxTime}ms`);
    //
    // assert(avgTime < 500, `Average time ${avgTime.toFixed(2)}ms under 500ms`);
    // assert(maxTime < 1000, `Max time ${maxTime}ms under 1000ms`);

    console.log('‚ö†Ô∏è  TODO: Add performance test for {{COMMAND_NAME}}');

  } catch (error) {
    console.error('‚ùå Performance test failed:', error.message);
    throw error;
  }
}

/**
 * Test 6: {{COMMAND_NAME}} with various parameter combinations
 */
async function test{{CLASS_NAME}}ParameterCombinations() {
  console.log('\nüß™ Test 6: {{COMMAND_NAME}} with various parameter combinations');

  try {
    const { jtag } = await import('../../../../browser-index');
    const client = await jtag.connect();

    // TODO: Test edge cases and parameter combinations
    // Example:
    // const testCases = [
    //   { requiredParam: 'a', optionalParam: true },
    //   { requiredParam: 'very-long-string-to-test-limits', optionalParam: false },
    //   { requiredParam: '123', optionalParam: true },
    // ];
    //
    // for (const params of testCases) {
    //   const { result } = await testClientCommandExecution<{{CLASS_NAME}}Result>(
    //     client,
    //     '{{COMMAND_NAME}}',
    //     params,
    //     5000
    //   );
    //   assert(result.success === true, `{{CLASS_NAME}} succeeds with params: ${JSON.stringify(params)}`);
    // }

    console.log('‚ö†Ô∏è  TODO: Add parameter combination tests for {{COMMAND_NAME}}');

  } catch (error) {
    console.error('‚ùå Parameter combination test failed:', error.message);
    throw error;
  }
}

/**
 * Run all integration tests
 */
async function runAll{{CLASS_NAME}}IntegrationTests() {
  console.log('üöÄ Starting {{CLASS_NAME}} Command Integration Tests\n');
  console.log('‚ö†Ô∏è  PREREQUISITES:');
  console.log('   - Server running: npm start (wait 90+ seconds)');
  console.log('   - Browser client connected\n');

  try {
    await test{{CLASS_NAME}}ClientConnection();
    await testReal{{CLASS_NAME}}Execution();
    await test{{CLASS_NAME}}MissingParams();
    await test{{CLASS_NAME}}OptionalParams();
    await test{{CLASS_NAME}}Performance();
    await test{{CLASS_NAME}}ParameterCombinations();

    console.log('\nüéâ ALL {{CLASS_NAME}} INTEGRATION TESTS PASSED!');
    console.log('üìã Validated:');
    console.log('  ‚úÖ Client connection to live system');
    console.log('  ‚úÖ Real command execution via WebSocket');
    console.log('  ‚úÖ ValidationError handling for missing params');
    console.log('  ‚úÖ Optional parameter defaults');
    console.log('  ‚úÖ Performance under load');
    console.log('  ‚úÖ Various parameter combinations');

  } catch (error) {
    console.error('\n‚ùå {{CLASS_NAME}} integration tests failed:', error.message);
    console.error('   Make sure server is running: npm start');
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  runAll{{CLASS_NAME}}IntegrationTests();
} else {
  module.exports = { runAll{{CLASS_NAME}}IntegrationTests };
}
