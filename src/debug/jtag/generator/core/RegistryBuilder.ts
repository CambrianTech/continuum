/**
 * RegistryBuilder - Generate registry files with imports and exports
 *
 * Extracted from generate-structure.ts for Phase 2b refactoring.
 * Builds TypeScript registry files that import and export entry arrays.
 */

import { writeFileSync } from 'fs';
import { join, relative } from 'path';
import type { EntryInfo } from './EntryExtractor';

/**
 * Configuration for registry generation
 */
export interface RegistryConfig {
  environment: 'browser' | 'server';
  outputFile: string;
  typeImports: Record<string, string>;  // typename -> import path
  entryTypes: EntryTypeConfig[];
}

/**
 * Configuration for a specific entry type (command, widget, etc.)
 */
export interface EntryTypeConfig {
  name: string;                    // e.g., "command"
  pluralName: string;              // e.g., "commands"
  typeScriptTypeName: string;      // e.g., "CommandEntry"
  arrayName: string;               // e.g., "BROWSER_COMMANDS" (use {ENV} token)
  entryTemplate: string;           // e.g., "{ name: '{name}', handler: {className} }"
}

export class RegistryBuilder {
  private rootPath: string;

  constructor(rootPath: string) {
    this.rootPath = rootPath;
  }

  /**
   * Generate a registry file from entries
   *
   * @param config - Registry configuration
   * @param entries - Map of entry type name to entry list
   */
  generate(
    config: RegistryConfig,
    entries: Map<string, EntryInfo[]>
  ): void {
    const content = this.buildRegistryContent(config, entries);

    // Handle both absolute and relative paths
    const fullOutputPath = config.outputFile.startsWith('/')
      ? config.outputFile
      : join(this.rootPath, config.outputFile);

    writeFileSync(fullOutputPath, content, 'utf8');

    const totalEntries = Array.from(entries.values()).reduce((sum, list) => sum + list.length, 0);
    console.log(`âœ… Generated ${config.outputFile} with ${totalEntries} entries`);
  }

  /**
   * Build registry file content
   */
  private buildRegistryContent(
    config: RegistryConfig,
    allEntries: Map<string, EntryInfo[]>
  ): string {
    const sections: string[] = [];

    // Header
    sections.push(this.buildHeader(config, allEntries));

    // Imports by entry type
    sections.push(this.buildImports(config, allEntries));

    // Type imports
    sections.push(this.buildTypeImports(config));

    // Exports
    sections.push(this.buildExports(config, allEntries));

    return sections.join('\n') + '\n';
  }

  /**
   * Build file header comment
   */
  private buildHeader(
    config: RegistryConfig,
    allEntries: Map<string, EntryInfo[]>
  ): string {
    const envCap = this.capitalize(config.environment);

    const entryTypeCounts = Array.from(allEntries.entries())
      .map(([type, entries]) => `${entries.length} ${type}${entries.length !== 1 ? 's' : ''}`)
      .join(' and ');

    return `/**
 * ${envCap} Structure Registry - Auto-generated on ${new Date().toISOString()}
 *
 * Contains ${entryTypeCounts}.
 * Generated by scripts/generate-structure.ts - DO NOT EDIT MANUALLY
 */`;
  }

  /**
   * Build class imports for each entry type
   */
  private buildImports(
    config: RegistryConfig,
    allEntries: Map<string, EntryInfo[]>
  ): string {
    const sections: string[] = [];
    const envCap = this.capitalize(config.environment);

    Array.from(allEntries.entries()).forEach(([entryTypeName, entries]) => {
      if (entries.length > 0) {
        const entryType = config.entryTypes.find(et => et.name === entryTypeName);
        sections.push(`\n// ${envCap} ${entryType?.pluralName ?? entryTypeName} Imports`);
        sections.push(entries.map(e => `import { ${e.className} } from '${e.importPath}';`).join('\n'));
      }
    });

    return sections.join('\n');
  }

  /**
   * Build type imports
   */
  private buildTypeImports(config: RegistryConfig): string {
    const sections: string[] = ['\n// Types'];

    for (const [typeName, importPath] of Object.entries(config.typeImports)) {
      const outputDir = join(this.rootPath, config.outputFile).replace(/[^/]*$/, '');
      const fullImportPath = join(this.rootPath, importPath + '.ts');
      const relativeImportPath = relative(outputDir, fullImportPath)
        .replace('.ts', '')
        .replace(/\\/g, '/');

      sections.push(`import type { ${typeName} } from './${relativeImportPath}';`);
    }

    return sections.join('\n');
  }

  /**
   * Build export arrays
   */
  private buildExports(
    config: RegistryConfig,
    allEntries: Map<string, EntryInfo[]>
  ): string {
    const sections: string[] = [];
    const envCap = this.capitalize(config.environment);
    const envUpper = config.environment.toUpperCase();

    sections.push(`\n/**\n * ${envCap} Environment Registry\n */`);

    Array.from(allEntries.entries()).forEach(([entryTypeName, entries], index) => {
      if (entries.length > 0) {
        const entryType = config.entryTypes.find(et => et.name === entryTypeName);
        if (entryType) {
          const arrayName = entryType.arrayName.replace('{ENV}', envUpper);
          const typeName = entryType.typeScriptTypeName;

          sections.push(`export const ${arrayName}: ${typeName}[] = [`);

          const entryStrings = entries.map(entry => {
            return entryType.entryTemplate
              .replace(/\{name\}/g, entry.name)
              .replace(/\{className\}/g, entry.className)
              .replace(/\{importPath\}/g, entry.importPath);
          });

          sections.push(entryStrings.join(',\n'));
          sections.push('];');

          if (index < allEntries.size - 1) {
            sections.push('');
          }
        }
      }
    });

    return sections.join('\n');
  }

  /**
   * Capitalize first letter of string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
