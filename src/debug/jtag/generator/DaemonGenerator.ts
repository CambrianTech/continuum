/**
 * DaemonGenerator - Generate daemon files from declarative specs
 *
 * Phase 4 Task 3: Extend ModuleGenerator for daemon generation
 * Uses DAEMON-PATTERNS.md knowledge to create properly structured daemons
 */

import { ModuleGenerator, type GenerateOptions } from './ModuleGenerator';
import type { DaemonSpec } from './DaemonTypes';
import * as path from 'path';

export class DaemonGenerator extends ModuleGenerator<DaemonSpec> {
  private currentSpec?: DaemonSpec; // Temporary storage for writeFiles

  /**
   * Get module type (for logging)
   */
  protected getModuleType(): string {
    return 'daemon';
  }

  /**
   * Get module name from spec (for logging)
   */
  protected getModuleName(spec: DaemonSpec): string {
    return spec.name;
  }

  /**
   * Get output directory for this daemon
   */
  protected getOutputDir(spec: DaemonSpec): string {
    return path.join(this.rootPath, 'daemons', spec.name);
  }

  /**
   * Render all templates for this daemon
   * Returns rendered content for each file
   *
   * TODO (Task 2): Create daemon templates and implement rendering
   */
  protected renderTemplates(spec: DaemonSpec): Record<string, string> {
    this.currentSpec = spec; // Store for writeFiles

    // TODO: Implement template rendering in Task 2
    // For now, generate placeholder content based on DAEMON-PATTERNS.md structure
    const className = this.specNameToClassName(spec.name);

    return {
      sharedTypes: this.generateSharedTypes(spec, className),
      sharedDaemon: this.generateSharedDaemon(spec, className),
      browser: this.generateBrowser(spec, className),
      server: this.generateServer(spec, className),
      readme: this.generateReadme(spec, className)
    };
  }

  /**
   * Write rendered templates to disk
   */
  protected writeFiles(baseDir: string, rendered: Record<string, string>): void {
    if (!this.currentSpec) {
      throw new Error('currentSpec not set - renderTemplates must be called first');
    }

    const className = this.specNameToClassName(this.currentSpec.name);

    // Write shared types file
    const sharedTypesPath = path.join(baseDir, 'shared', `${className}Types.ts`);
    this.writeFile(sharedTypesPath, rendered.sharedTypes);

    // Write shared daemon implementation
    const sharedDaemonPath = path.join(baseDir, 'shared', `${className}.ts`);
    this.writeFile(sharedDaemonPath, rendered.sharedDaemon);

    // Write browser forwarding layer
    const browserPath = path.join(baseDir, 'browser', `${className}Browser.ts`);
    this.writeFile(browserPath, rendered.browser);

    // Write server implementation
    const serverPath = path.join(baseDir, 'server', `${className}Server.ts`);
    this.writeFile(serverPath, rendered.server);

    // Write README
    const readmePath = path.join(baseDir, 'README.md');
    this.writeFile(readmePath, rendered.readme);

    // Print next steps
    console.log(`\nüìã Next steps:`);
    console.log(`   1. Implement daemon logic in ${sharedDaemonPath}`);
    console.log(`   2. Add business logic for each operation`);
    console.log(`   3. Test daemon integration`);
    console.log(`\nüí° Daemon follows 85/15 split pattern:`);
    console.log(`   - 80-90% logic in shared/`);
    console.log(`   - 5-10% browser forwarding in browser/`);
    console.log(`   - 5-10% server initialization in server/`);

    // Clean up
    this.currentSpec = undefined;
  }

  // ==================== Helper Methods ====================

  /**
   * Convert spec name (kebab-case) to PascalCase class name
   * Examples: 'lora-manager' ‚Üí 'LoRAManager', 'training-pipeline' ‚Üí 'TrainingPipeline'
   */
  private specNameToClassName(name: string): string {
    return name.split('-').map(part =>
      part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
    ).join('');
  }

  // ==================== Placeholder Template Methods (TODO: Replace with real templates in Task 2) ====================

  private generateSharedTypes(spec: DaemonSpec, className: string): string {
    // Placeholder - will be replaced with template in Task 2
    return `/**
 * ${className}Types - Type definitions for ${spec.name} daemon
 * Generated by DaemonGenerator
 */

import type { JTAGPayload } from '../../../system/core/shared/JTAGPayload';
import type { BaseResponsePayload } from '../../../system/core/shared/BaseResponsePayload';

// TODO: Add operation-specific payload interfaces
// TODO: Add result type interfaces
// TODO: Add state interfaces (if needed)

export interface ${className}Payload extends JTAGPayload {
  readonly operation: string;
  // TODO: Add operation-specific fields
}

export interface ${className}Result extends BaseResponsePayload {
  // TODO: Add result fields
}
`;
  }

  private generateSharedDaemon(spec: DaemonSpec, className: string): string {
    // Placeholder - will be replaced with template in Task 2
    return `/**
 * ${className} - ${spec.description}
 * Generated by DaemonGenerator
 *
 * Following DAEMON-PATTERNS.md: 85/15 split architecture
 */

import { DaemonBase } from '../../command-daemon/shared/DaemonBase';
import type { JTAGMessage } from '../../../system/core/shared/JTAGMessage';
import type { BaseResponsePayload } from '../../../system/core/shared/BaseResponsePayload';
import type { ${className}Payload, ${className}Result } from './${className}Types';

export abstract class ${className} extends DaemonBase {
  protected static sharedInstance: ${className} | undefined;

  constructor() {
    super('${spec.name}');
  }

  /**
   * Initialize daemon
   */
  protected async initialize(): Promise<void> {
    // TODO: Implement initialization logic
    ${spec.lifecycle?.onStart ? `// ${spec.lifecycle.onStart}` : ''}
  }

  /**
   * Handle incoming messages
   */
  async handleMessage(message: JTAGMessage): Promise<BaseResponsePayload> {
    const payload = message.payload as ${className}Payload;

    try {
      switch (payload.operation) {
        // TODO: Add operation cases
        default:
          return this.errorResponse('Unknown operation: ' + payload.operation);
      }
    } catch (error) {
      return this.errorResponse((error as Error).message);
    }
  }

  /**
   * Shutdown daemon
   */
  async shutdown(): Promise<void> {
    // TODO: Implement shutdown logic
    ${spec.lifecycle?.onStop ? `// ${spec.lifecycle.onStop}` : ''}
  }

  // ==================== Static Clean Interface ====================

  static initialize(instance: ${className}): void {
    ${className}.sharedInstance = instance;
  }

  // TODO: Add static methods for each operation
}
`;
  }

  private generateBrowser(spec: DaemonSpec, className: string): string {
    // Placeholder - will be replaced with template in Task 2
    return `/**
 * ${className}Browser - Browser forwarding layer for ${spec.name} daemon
 * Generated by DaemonGenerator
 */

import { ${className} } from '../shared/${className}';

export class ${className}Browser extends ${className} {
  // Browser-specific initialization (if any)
  // Typically just forwards to server via router
}
`;
  }

  private generateServer(spec: DaemonSpec, className: string): string {
    // Placeholder - will be replaced with template in Task 2
    return `/**
 * ${className}Server - Server implementation for ${spec.name} daemon
 * Generated by DaemonGenerator
 */

import { ${className} } from '../shared/${className}';

export class ${className}Server extends ${className} {
  // Server-specific initialization
  // Database access, adapter registration, etc.
}
`;
  }

  private generateReadme(spec: DaemonSpec, className: string): string {
    const jobsList = spec.jobs.map(j => `- **${j.name}**: ${j.description || 'TODO'}`).join('\n');
    const eventsList = spec.events?.map(e => `- **${e.name}**: ${e.description || 'TODO'}`).join('\n') || '(None)';

    return `# ${className} Daemon

${spec.description}

## Operations

${jobsList || '(None defined yet)'}

## Events Emitted

${eventsList}

## Lifecycle

- **onStart**: ${spec.lifecycle?.onStart || 'TODO'}
- **onStop**: ${spec.lifecycle?.onStop || 'TODO'}

## Architecture

This daemon follows the **85/15 split pattern**:
- **shared/${className}.ts**: Core business logic (80-90%)
- **browser/${className}Browser.ts**: Browser forwarding layer (5-10%)
- **server/${className}Server.ts**: Server-specific initialization (5-10%)

## Usage

\`\`\`typescript
// TODO: Add usage examples
\`\`\`

---

*Generated by DaemonGenerator*
`;
  }

  /**
   * Generate from a JSON file containing DaemonSpec
   */
  generateFromFile(specFilePath: string, outputDir?: string, options?: GenerateOptions): void {
    const fs = require('fs');
    const specJson = fs.readFileSync(specFilePath, 'utf-8');
    const spec: DaemonSpec = JSON.parse(specJson);
    this.generate(spec, outputDir, options);
  }
}

// CLI execution
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.error('Usage: npx tsx DaemonGenerator.ts <spec-file.json> [output-dir] [--force] [--backup]');
    console.error('\nFlags:');
    console.error('  --force   Overwrite existing daemon');
    console.error('  --backup  Create backup before overwriting (requires --force)');
    process.exit(1);
  }

  const rootPath = path.join(__dirname, '..');
  const generator = new DaemonGenerator(rootPath);

  const specFile = args[0];
  const flagArgs = args.filter(a => a.startsWith('--'));
  const nonFlagArgs = args.filter(a => !a.startsWith('--'));

  const options = {
    force: flagArgs.includes('--force'),
    backup: flagArgs.includes('--backup')
  };

  const outputDir = nonFlagArgs[1]; // Second non-flag arg is output dir

  if (options.backup && !options.force) {
    console.error('‚ùå ERROR: --backup requires --force');
    process.exit(1);
  }

  generator.generateFromFile(specFile, outputDir, options);
}

export { DaemonSpec };
