/**
 * WidgetGenerator - Generate widget files with all wiring
 *
 * Generates:
 * - Widget TypeScript file (extends BaseWidget)
 * - SCSS styles file (imports from _variables.scss)
 * - Recipe JSON file
 * - Seeds recipe to database
 * - Updates ContentTypeRegistry if needed
 *
 * Eliminates manual wiring pain by automating:
 * - Widget class with proper BaseWidget extension
 * - Positron context emission
 * - Recipe ‚Üí database sync
 * - Tag name conventions (PascalCase ‚Üí kebab-case-widget)
 */

import { ModuleGenerator, type GenerateOptions } from './ModuleGenerator';
import * as path from 'path';
import * as fs from 'fs';

export interface WidgetSpec {
  /** Widget name in PascalCase WITHOUT "Widget" suffix, e.g., "WebView", "UserProfile", "Test" */
  name: string;
  /** Brief description of what this widget does */
  description: string;
  /** Display name shown in UI tabs */
  displayName: string;
  /** URL path prefix, e.g., "/browser", "/profile" */
  pathPrefix: string;
  /** Whether this widget needs an entityId (like userId, roomId) */
  requiresEntity: boolean;
  /** Right panel config: null = hidden, { room: 'help' } = show chat */
  rightPanel?: { room: string; compact?: boolean } | null;
  /** Initial placeholder content */
  placeholderTitle?: string;
  placeholderText?: string;
}

export class WidgetGenerator extends ModuleGenerator<WidgetSpec> {
  private currentSpec?: WidgetSpec;

  protected getModuleType(): string {
    return 'widget';
  }

  protected getModuleName(spec: WidgetSpec): string {
    return spec.name;
  }

  protected getOutputDir(spec: WidgetSpec): string {
    const kebabName = this.toKebabCase(spec.name);
    return path.join(this.rootPath, 'widgets', kebabName);
  }

  /**
   * Convert PascalCase to kebab-case
   */
  private toKebabCase(name: string): string {
    return name
      .replace(/([A-Z])/g, (match, p1, offset) =>
        offset > 0 ? '-' + p1.toLowerCase() : p1.toLowerCase()
      );
  }

  /**
   * Get the widget tag name (kebab-case-widget)
   */
  private getTagName(spec: WidgetSpec): string {
    return this.toKebabCase(spec.name) + '-widget';
  }

  protected renderTemplates(spec: WidgetSpec): Record<string, string> {
    this.currentSpec = spec;
    const className = spec.name + 'Widget';
    const tagName = this.getTagName(spec);
    const kebabName = this.toKebabCase(spec.name);

    return {
      widget: this.renderWidgetTemplate(spec, className),
      styles: this.renderStylesTemplate(spec, kebabName),
      recipe: this.renderRecipeTemplate(spec, tagName),
    };
  }

  private renderWidgetTemplate(spec: WidgetSpec, className: string): string {
    const kebabName = this.toKebabCase(spec.name);

    return `/**
 * ${className} - ${spec.description}
 *
 * Generated by WidgetGenerator
 */

import { BaseWidget } from '../shared/BaseWidget';
import { PositronWidgetState } from '../shared/services/state/PositronWidgetState';

export class ${className} extends BaseWidget {
  constructor() {
    super({
      widgetName: '${className}',
      template: undefined,
      styles: undefined,
      enableAI: false,
      enableDatabase: false,
      enableRouterEvents: false,
      enableScreenshots: false
    });
  }

  protected async onWidgetInitialize(): Promise<void> {
    console.log('üîß ${className}: Initializing...');
    this.emitPositronContext();
  }

  private emitPositronContext(): void {
    PositronWidgetState.emit(
      {
        widgetType: '${kebabName}',
        title: '${spec.displayName}',
        metadata: {}
      },
      { action: 'viewing', target: '${spec.displayName.toLowerCase()}' }
    );
  }

  protected async renderWidget(): Promise<void> {
    const styles = \`
      :host {
        display: block;
        height: 100%;
        overflow: hidden;
      }

      .${kebabName}-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        background: var(--bg-panel, #1a1a2e);
      }

      .${kebabName}-header {
        padding: 16px;
        border-bottom: 1px solid var(--border-color, rgba(0, 212, 255, 0.2));
      }

      .${kebabName}-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-dim, rgba(255, 255, 255, 0.5));
        font-size: 16px;
      }

      .placeholder-text {
        text-align: center;
        padding: 40px;
      }

      .placeholder-text h2 {
        color: var(--content-accent, #00d4ff);
        margin-bottom: 16px;
      }
    \`;

    const template = \`
      <div class="${kebabName}-container">
        <div class="${kebabName}-content">
          <div class="placeholder-text">
            <h2>${spec.placeholderTitle || spec.displayName}</h2>
            <p>${spec.placeholderText || 'Widget content goes here.'}</p>
          </div>
        </div>
      </div>
    \`;

    this.shadowRoot!.innerHTML = \`<style>\${styles}</style>\${template}\`;
  }

  protected async onWidgetCleanup(): Promise<void> {
    console.log('üßπ ${className}: Cleanup complete');
  }
}

// Registration handled by centralized BROWSER_WIDGETS registry
`;
  }

  private renderStylesTemplate(spec: WidgetSpec, kebabName: string): string {
    return `/**
 * ${spec.name}Widget Styles
 *
 * Uses shared SCSS variables from widgets/shared/styles/_variables.scss
 */

@import '../shared/styles/variables';
@import '../shared/styles/mixins';

.${kebabName}-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: $bg-panel;
}

.${kebabName}-header {
  padding: $spacing-lg;
  border-bottom: $border-primary;

  h1 {
    color: $color-primary;
    font-size: $font-size-xl;
    margin: 0;
  }
}

.${kebabName}-content {
  flex: 1;
  padding: $spacing-lg;
  overflow-y: auto;
  color: $color-text;
}

// Add component-specific styles below
`;
  }

  private renderRecipeTemplate(spec: WidgetSpec, tagName: string): string {
    const rightPanelJson = spec.rightPanel === null
      ? 'null'
      : spec.rightPanel
        ? JSON.stringify({ widgets: ['chat-widget'], config: spec.rightPanel }, null, 4).replace(/\n/g, '\n    ')
        : '{ "widgets": ["chat-widget"], "config": { "room": "help", "compact": true } }';

    return `{
  "uniqueId": "${this.toKebabCase(spec.name)}",
  "name": "${spec.displayName}",
  "displayName": "${spec.displayName}",
  "description": "${spec.description}",
  "version": 1,

  "layout": {
    "main": ["${tagName}"],
    "right": ${rightPanelJson}
  },

  "pipeline": [
    {
      "command": "rag/build",
      "params": {
        "maxMessages": 10,
        "includeParticipants": false
      },
      "outputTo": "ragContext"
    },
    {
      "command": "ai/generate",
      "params": {
        "ragContext": "$ragContext",
        "temperature": 0.5
      }
    }
  ],

  "ragTemplate": {
    "messageHistory": {
      "maxMessages": 10,
      "orderBy": "chronological",
      "includeTimestamps": true
    },
    "participants": {
      "includeRoles": false,
      "includeExpertise": false,
      "includeHistory": false
    }
  },

  "strategy": {
    "conversationPattern": "collaborative",
    "responseRules": [
      "Provide helpful guidance",
      "Be concise and clear"
    ],
    "decisionCriteria": [
      "What is the user trying to accomplish?"
    ]
  },

  "isPublic": true,
  "tags": ["${this.toKebabCase(spec.name)}"]
}
`;
  }

  protected writeFiles(baseDir: string, rendered: Record<string, string>): void {
    if (!this.currentSpec) {
      throw new Error('currentSpec not set');
    }

    const className = this.currentSpec.name + 'Widget';
    const kebabName = this.toKebabCase(this.currentSpec.name);

    // Write widget TypeScript file
    const widgetPath = path.join(baseDir, `${className}.ts`);
    this.writeFile(widgetPath, rendered.widget);

    // Write SCSS styles file
    const stylesDir = path.join(baseDir, 'styles');
    const stylesPath = path.join(stylesDir, `${kebabName}.scss`);
    this.writeFile(stylesPath, rendered.styles);

    // Write recipe JSON file
    const recipePath = path.join(this.rootPath, 'system', 'recipes', `${kebabName}.json`);
    this.writeFile(recipePath, rendered.recipe);

    // Print next steps
    console.log(`\nüìã Next steps:`);
    console.log(`   1. Run: npm run build:ts`);
    console.log(`   2. Run: npm start (seeds recipe to database)`);
    console.log(`   3. Verify widget loads: ./jtag interface/navigate --url="http://localhost:9000${this.currentSpec.pathPrefix}"`);
    console.log(`   4. Customize the widget: ${widgetPath}`);
    console.log(`\n‚ö†Ô∏è  If widget doesn't appear:`);
    console.log(`   - Check browser console for registration errors`);
    console.log(`   - Verify recipe was seeded: ./jtag data/list --collection=recipes --filter='{"uniqueId":"${kebabName}"}'`);

    this.currentSpec = undefined;
  }
}

// CLI execution
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.error('Usage: npx tsx generator/WidgetGenerator.ts <spec-file.json> [--force] [--backup]');
    console.error('   or: npx tsx generator/WidgetGenerator.ts --template');
    console.error('   or: npx tsx generator/WidgetGenerator.ts --test');
    console.error('\nFlags:');
    console.error('  --force   Overwrite existing widget');
    console.error('  --backup  Create backup before overwriting');
    process.exit(1);
  }

  const rootPath = path.join(__dirname, '..');
  const generator = new WidgetGenerator(rootPath);

  if (args[0] === '--template') {
    const exampleSpec: WidgetSpec = {
      name: 'Example',
      description: 'Brief description of what this widget does',
      displayName: 'Example',
      pathPrefix: '/example',
      requiresEntity: false,
      rightPanel: { room: 'help', compact: true },
      placeholderTitle: 'Example Widget',
      placeholderText: 'This is placeholder content for the example widget.'
    };
    console.log(JSON.stringify(exampleSpec, null, 2));
    console.log('\nüìù Copy the JSON above, edit it, save to a file, then run:');
    console.log('   npx tsx generator/WidgetGenerator.ts <your-spec-file.json>');
    process.exit(0);
  } else if (args[0] === '--test') {
    const testSpec: WidgetSpec = {
      name: 'Test',
      description: 'Test widget for generator testing',
      displayName: 'Test',
      pathPrefix: '/test',
      requiresEntity: false,
      rightPanel: null,
      placeholderTitle: 'Test Widget',
      placeholderText: 'Generated by WidgetGenerator test mode.'
    };
    console.log('üß™ Test Mode: Generating test widget to /tmp...\n');
    generator.generate(testSpec, '/tmp/generated-widget-test');
  } else {
    // Normal mode: generate from spec file
    const specFile = args[0];
    const flagArgs = args.filter(a => a.startsWith('--'));

    const options: GenerateOptions = {
      force: flagArgs.includes('--force'),
      backup: flagArgs.includes('--backup')
    };

    if (options.backup && !options.force) {
      console.error('‚ùå ERROR: --backup requires --force');
      process.exit(1);
    }

    const specJson = fs.readFileSync(specFile, 'utf-8');
    const spec: WidgetSpec = JSON.parse(specJson);
    generator.generate(spec, undefined, options);
  }
}

export { WidgetSpec };
