/**
 * RunArtifact - Universal run artifact system for all Continuum operations
 * 
 * The "mechanic's toolbox" - provides consistent diagnostic capabilities across:
 * - Git hook runs (Saint Peter verification at the gates)
 * - Portal sessions (interactive debugging) 
 * - Verification runs (emergency recovery)
 * - DevTools automation (browser diagnostics)
 * - Persona executions (agent debugging)
 * - Any future run type
 * 
 * "God mode" accessibility - these tools work even when Continuum is catastrophically broken
 */

const fs = require('fs').promises;
const path = require('path');

class RunArtifact {
    /**
     * Standard run artifact structure - consistent across all run types
     * @param {string} baseDir - Base directory (usually .continuum)
     * @param {string} runType - Type of run (git, portal, verification, devtools, etc.)
     * @param {string} runId - Unique run identifier
     */
    constructor(baseDir, runType, runId) {
        this.baseDir = baseDir;
        this.runType = runType;
        this.runId = runId;
        this.runDir = path.join(baseDir, runType, `run_${runId}`);
        
        // Standard artifact files that EVERY run type supports
        this.artifacts = {
            // Core metadata
            'run.json': 'Run metadata and status',
            'summary.txt': 'Human-readable run summary',
            
            // Diagnostic essentials (the mechanic's core tools)
            'client-logs.txt': 'Client-side logs and activity',
            'server-logs.txt': 'Server/daemon logs and activity', 
            'console-logs.txt': 'Browser console output',
            'error-logs.txt': 'Error messages and stack traces',
            
            // Visual evidence
            'ui-capture.png': 'Screenshot of UI state',
            'ui-before.png': 'UI state before operation',
            'ui-after.png': 'UI state after operation',
            
            // Execution artifacts
            'js-execution.txt': 'JavaScript execution results',
            'commands.txt': 'Commands executed during run',
            'timing.txt': 'Performance and timing data',
            
            // External data
            'git-status.txt': 'Git repository state',
            'environment.txt': 'Environment variables and context',
            'network.txt': 'Network connections and activity'
        };
    }

    /**
     * Initialize run artifact directory with standard structure
     * @param {Object} metadata - Initial run metadata
     */
    async initialize(metadata = {}) {
        try {
            // Create run directory
            await fs.mkdir(this.runDir, { recursive: true });
            
            // Create standard subdirectories
            await fs.mkdir(path.join(this.runDir, 'screenshots'), { recursive: true });
            await fs.mkdir(path.join(this.runDir, 'logs'), { recursive: true });
            await fs.mkdir(path.join(this.runDir, 'artifacts'), { recursive: true });
            
            // Initialize run metadata
            const runMetadata = {
                runType: this.runType,
                runId: this.runId,
                timestamp: new Date().toISOString(),
                startTime: Date.now(),
                status: 'RUNNING',
                capabilities: Object.keys(this.artifacts),
                ...metadata
            };
            
            await this.writeArtifact('run.json', JSON.stringify(runMetadata, null, 2));
            
            // Initialize empty artifact files with headers
            await this.initializeArtifactFiles();
            
            console.log(`üîß Run artifact initialized: ${this.runType}/run_${this.runId}`);
            return this.runDir;
            
        } catch (error) {
            console.error('‚ùå Run artifact initialization failed:', error);
            throw error;
        }
    }

    /**
     * Initialize standard artifact files with descriptive headers
     */
    async initializeArtifactFiles() {
        const timestamp = new Date().toISOString();
        const header = `# Continuum Run Artifact - ${this.runType.toUpperCase()}\n# Run ID: ${this.runId}\n# Timestamp: ${timestamp}\n# Auto-generated by RunArtifact system\n\n`;
        
        // Initialize text-based artifacts
        const textArtifacts = [
            'client-logs.txt', 'server-logs.txt', 'console-logs.txt', 
            'error-logs.txt', 'js-execution.txt', 'commands.txt', 
            'timing.txt', 'git-status.txt', 'environment.txt', 'network.txt'
        ];
        
        for (const artifact of textArtifacts) {
            try {
                await this.writeArtifact(artifact, header);
            } catch (error) {
                console.warn(`‚ö†Ô∏è Failed to initialize ${artifact}:`, error.message);
            }
        }
        
        // Create summary with basic info
        const summary = `${header}Run Summary\n===========\nRun Type: ${this.runType}\nRun ID: ${this.runId}\nStatus: RUNNING\nStarted: ${timestamp}\n\n`;
        await this.writeArtifact('summary.txt', summary);
    }

    /**
     * Write to artifact file (append or overwrite)
     * @param {string} artifactName - Name of artifact file
     * @param {string|Buffer} content - Content to write
     * @param {boolean} append - Whether to append (default: false)
     */
    async writeArtifact(artifactName, content, append = false) {
        try {
            const artifactPath = path.join(this.runDir, artifactName);
            
            if (append) {
                await fs.appendFile(artifactPath, content);
            } else {
                await fs.writeFile(artifactPath, content);
            }
            
            return artifactPath;
            
        } catch (error) {
            console.error(`‚ö†Ô∏è Failed to write artifact ${artifactName}:`, error);
            throw error;
        }
    }

    /**
     * Read artifact file content
     * @param {string} artifactName - Name of artifact file
     * @returns {string|Buffer} File content
     */
    async readArtifact(artifactName) {
        try {
            const artifactPath = path.join(this.runDir, artifactName);
            
            // For images, return buffer; for text, return string
            if (artifactName.endsWith('.png') || artifactName.endsWith('.jpg')) {
                return await fs.readFile(artifactPath);
            } else {
                return await fs.readFile(artifactPath, 'utf8');
            }
            
        } catch (error) {
            console.error(`‚ö†Ô∏è Failed to read artifact ${artifactName}:`, error);
            throw error;
        }
    }

    /**
     * Add timestamped log entry to any log artifact
     * @param {string} logType - Type of log (client-logs, server-logs, etc.)
     * @param {string} message - Log message
     * @param {string} level - Log level (INFO, WARN, ERROR, DEBUG)
     */
    async addLogEntry(logType, message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] ${level}: ${message}\n`;
        await this.writeArtifact(logType, logEntry, true);
    }

    /**
     * Store screenshot with automatic naming and organization
     * @param {string} sourcePath - Source screenshot path  
     * @param {string} purpose - Purpose of screenshot (ui-capture, ui-before, ui-after, etc.)
     * @param {string} customName - Optional custom filename
     */
    async storeScreenshot(sourcePath, purpose = 'ui-capture', customName = null) {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = customName || `${purpose}_${timestamp}.png`;
            const destPath = path.join(this.runDir, 'screenshots', filename);
            
            await fs.copyFile(sourcePath, destPath);
            
            // Also create the standard artifact reference
            if (purpose === 'ui-capture' || purpose === 'ui-before' || purpose === 'ui-after') {
                const standardPath = path.join(this.runDir, `${purpose}.png`);
                await fs.copyFile(sourcePath, standardPath);
            }
            
            await this.addLogEntry('client-logs', `üì∏ Screenshot stored: ${filename} (${purpose})`);
            
            console.log(`üì∏ Screenshot stored: ${filename}`);
            return destPath;
            
        } catch (error) {
            console.error('‚ö†Ô∏è Failed to store screenshot:', error);
            throw error;
        }
    }

    /**
     * Complete run with final status and summary
     * @param {string} status - Final status (PASS, FAIL, ERROR, TIMEOUT)
     * @param {string} summary - Human-readable summary
     * @param {Object} results - Additional result data
     */
    async complete(status = 'PASS', summary = '', results = {}) {
        try {
            const endTime = Date.now();
            const runMetadata = JSON.parse(await this.readArtifact('run.json'));
            
            runMetadata.status = status;
            runMetadata.endTime = endTime;
            runMetadata.duration = endTime - runMetadata.startTime;
            runMetadata.summary = summary;
            runMetadata.results = results;
            runMetadata.completedAt = new Date().toISOString();
            
            await this.writeArtifact('run.json', JSON.stringify(runMetadata, null, 2));
            
            // Update summary file
            const finalSummary = `# Continuum Run Artifact - ${this.runType.toUpperCase()}
# Run ID: ${this.runId}
# Completed: ${runMetadata.completedAt}

Run Summary
===========
Status: ${status}
Duration: ${(runMetadata.duration / 1000).toFixed(1)}s
Summary: ${summary}

Results:
${JSON.stringify(results, null, 2)}

Artifacts Available:
${Object.keys(this.artifacts).map(a => `- ${a}: ${this.artifacts[a]}`).join('\n')}
`;
            
            await this.writeArtifact('summary.txt', finalSummary);
            
            console.log(`‚úÖ Run completed: ${this.runType}/run_${this.runId} (${status})`);
            return this.runDir;
            
        } catch (error) {
            console.error('‚ùå Run completion failed:', error);
            throw error;
        }
    }

    /**
     * Get run status and metadata
     */
    async getStatus() {
        try {
            const metadata = JSON.parse(await this.readArtifact('run.json'));
            return metadata;
        } catch (error) {
            return { status: 'UNKNOWN', error: error.message };
        }
    }

    /**
     * List all artifacts in this run
     */
    async listArtifacts() {
        try {
            const files = await fs.readdir(this.runDir);
            const artifacts = [];
            
            for (const file of files) {
                const filePath = path.join(this.runDir, file);
                const stats = await fs.stat(filePath);
                
                artifacts.push({
                    name: file,
                    size: stats.size,
                    modified: stats.mtime,
                    type: stats.isDirectory() ? 'directory' : 'file'
                });
            }
            
            return artifacts;
            
        } catch (error) {
            console.error('‚ö†Ô∏è Failed to list artifacts:', error);
            return [];
        }
    }

    /**
     * Static helper: Create RunArtifact from any existing run directory
     * @param {string} runPath - Path to existing run directory
     */
    static fromExistingRun(runPath) {
        const pathParts = runPath.split(path.sep);
        const runDir = pathParts[pathParts.length - 1]; // run_xxxxx
        const runType = pathParts[pathParts.length - 2]; // git, portal, etc.
        const baseDir = pathParts.slice(0, -2).join(path.sep);
        const runId = runDir.replace('run_', '');
        
        return new RunArtifact(baseDir, runType, runId);
    }

    /**
     * Static helper: Discover all runs across all types
     * @param {string} baseDir - Base directory to search
     */
    static async discoverAllRuns(baseDir) {
        try {
            const runs = [];
            const entries = await fs.readdir(baseDir, { withFileTypes: true });
            
            for (const entry of entries) {
                if (entry.isDirectory()) {
                    const runTypeDir = path.join(baseDir, entry.name);
                    try {
                        const runDirs = await fs.readdir(runTypeDir);
                        
                        for (const runDir of runDirs) {
                            if (runDir.startsWith('run_')) {
                                const runPath = path.join(runTypeDir, runDir);
                                const artifact = RunArtifact.fromExistingRun(runPath);
                                const status = await artifact.getStatus();
                                
                                runs.push({
                                    runType: entry.name,
                                    runId: runDir.replace('run_', ''),
                                    path: runPath,
                                    status: status.status,
                                    timestamp: status.timestamp,
                                    duration: status.duration
                                });
                            }
                        }
                    } catch (e) {
                        // Skip directories that don't contain runs
                    }
                }
            }
            
            // Sort by timestamp (newest first)
            runs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            return runs;
            
        } catch (error) {
            console.error('‚ö†Ô∏è Failed to discover runs:', error);
            return [];
        }
    }
}

module.exports = RunArtifact;