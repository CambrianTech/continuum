#!/usr/bin/env node
/**
 * Layer 2 Integration Tests: RendererDaemon Template Processing
 * Middle-Out Testing Approach - Daemon template loading and processing
 * 
 * Tests that the daemon can load Layer 1 templates and process them correctly
 */

import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const currentDir = dirname(fileURLToPath(import.meta.url));
const templatesDir = join(currentDir, '..', 'templates');

console.log('ğŸ§ª Layer 2: RendererDaemon Template Processing');
console.log(`ğŸ“ Templates directory: ${templatesDir}`);
console.log('');

let testCount = 0;
let passCount = 0;
let failCount = 0;

function test(description, testFn) {
  testCount++;
  return testFn().then(() => {
    passCount++;
    console.log(`âœ… ${description}`);
  }).catch((error) => {
    failCount++;
    console.log(`âŒ ${description}`);
    console.log(`   Error: ${error.message}`);
  });
}

function expect(actual) {
  return {
    toBe: (expected) => {
      if (actual !== expected) {
        throw new Error(`Expected ${expected}, got ${actual}`);
      }
    },
    toContain: (substring) => {
      if (!actual.includes(substring)) {
        throw new Error(`Expected content to contain "${substring}"`);
      }
    },
    not: {
      toContain: (substring) => {
        if (actual.includes(substring)) {
          throw new Error(`Expected content to NOT contain "${substring}"`);
        }
      }
    },
    toBeGreaterThan: (value) => {
      if (actual <= value) {
        throw new Error(`Expected ${actual} to be greater than ${value}`);
      }
    }
  };
}

/**
 * Simulate RendererDaemon template processing logic
 * This replicates the handleWidgetLoaderGeneration method
 */
async function simulateTemplateProcessing(dynamicVersion = '1.0.0') {
  console.log(`ğŸ”„ Simulating template processing with version: ${dynamicVersion}`);
  
  // Load template files (same as RendererDaemon does)
  const baseWidgetTemplate = await fs.readFile(join(templatesDir, 'BaseWidget.ts'), 'utf-8');
  const widgetLoaderTemplate = await fs.readFile(join(templatesDir, 'widget-loader.ts'), 'utf-8');
  const chatWidgetTemplate = await fs.readFile(join(templatesDir, 'chat-widget.ts'), 'utf-8');
  const sidebarWidgetTemplate = await fs.readFile(join(templatesDir, 'sidebar-widget.ts'), 'utf-8');
  
  // Load HTML templates as separate assets
  const chatWidgetHTML = await fs.readFile(join(templatesDir, 'chat-widget.html'), 'utf-8');
  const sidebarWidgetHTML = await fs.readFile(join(templatesDir, 'sidebar-widget.html'), 'utf-8');

  // Inject version into HTML templates
  const processedChatHTML = chatWidgetHTML.replace(/\{\{CONTINUUM_VERSION\}\}/g, dynamicVersion);
  const processedSidebarHTML = sidebarWidgetHTML.replace(/\{\{CONTINUUM_VERSION\}\}/g, dynamicVersion);

  // Inject HTML templates into TypeScript components (escape for template strings)
  const chatWidgetCode = chatWidgetTemplate
    .replace(/\{\{CONTINUUM_VERSION\}\}/g, dynamicVersion)
    .replace(/\{\{CHAT_WIDGET_HTML\}\}/g, processedChatHTML.replace(/`/g, '\\`').replace(/\$/g, '\\$'));
  
  const sidebarWidgetCode = sidebarWidgetTemplate
    .replace(/\{\{CONTINUUM_VERSION\}\}/g, dynamicVersion)
    .replace(/\{\{SIDEBAR_WIDGET_HTML\}\}/g, processedSidebarHTML.replace(/`/g, '\\`').replace(/\$/g, '\\$'));
    
  const widgetLoaderCode = widgetLoaderTemplate.replace(/\{\{CONTINUUM_VERSION\}\}/g, dynamicVersion);

  // Combine templates into final widget loader (same as RendererDaemon)
  const finalCode = `// Widget Loader - Generated by RendererDaemon v${dynamicVersion}
// Templates loaded from: ${templatesDir}

${baseWidgetTemplate}

${chatWidgetCode}

${sidebarWidgetCode}

${widgetLoaderCode}`;

  return {
    finalCode,
    chatWidgetCode,
    sidebarWidgetCode,
    widgetLoaderCode,
    processedChatHTML,
    processedSidebarHTML
  };
}

// Layer 2 Integration Tests
console.log('ğŸ”„ Testing Template Loading:');

await test('RendererDaemon can load all template files', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  expect(result.finalCode.length).toBeGreaterThan(1000);
  expect(result.chatWidgetCode.length).toBeGreaterThan(500);
  expect(result.sidebarWidgetCode.length).toBeGreaterThan(500);
  expect(result.widgetLoaderCode.length).toBeGreaterThan(100);
});

await test('Template processing preserves TypeScript structure', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  
  // Verify final code contains BaseWidget architecture
  expect(result.finalCode).toContain('class ChatWidget extends BaseWidget');
  expect(result.finalCode).toContain('class ContinuumSidebar extends BaseWidget');
  expect(result.finalCode).toContain('abstract class BaseWidget');
  
  // Verify component registration
  expect(result.finalCode).toContain('customElements.define');
  expect(result.finalCode).toContain("'chat-widget'");
  expect(result.finalCode).toContain("'continuum-sidebar'");
});

console.log('');
console.log('ğŸ”„ Testing Version Injection:');

await test('Version injection works in HTML templates', async () => {
  const testVersion = '2.1.3';
  const result = await simulateTemplateProcessing(testVersion);
  
  expect(result.processedChatHTML).toContain(`v${testVersion}`);
  expect(result.processedSidebarHTML).toContain(`v${testVersion}`);
  expect(result.processedChatHTML).not.toContain('{{CONTINUUM_VERSION}}');
  expect(result.processedSidebarHTML).not.toContain('{{CONTINUUM_VERSION}}');
});

await test('Version injection works in TypeScript templates', async () => {
  const testVersion = '3.0.1';
  const result = await simulateTemplateProcessing(testVersion);
  
  expect(result.finalCode).toContain(`RendererDaemon v${testVersion}`);
  expect(result.finalCode).not.toContain('{{CONTINUUM_VERSION}}');
});

console.log('');
console.log('ğŸ”„ Testing HTML Template Injection:');

await test('HTML templates get injected into TypeScript classes', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  
  // Check that HTML content is injected (might be escaped in template strings)
  expect(result.finalCode).toContain('chat-header');
  expect(result.finalCode).toContain('chat-messages');
  expect(result.finalCode).toContain('sidebar-header');
  expect(result.finalCode).toContain('sidebar-content');
  
  // Verify placeholders are replaced
  expect(result.chatWidgetCode).not.toContain('{{CHAT_WIDGET_HTML}}');
  expect(result.sidebarWidgetCode).not.toContain('{{SIDEBAR_WIDGET_HTML}}');
  
  // Verify self-validation methods exist
  expect(result.finalCode).toContain('protected validate()');
  expect(result.finalCode).toContain('Chat widget validation passed');
  expect(result.finalCode).toContain('Sidebar widget validation passed');
});

await test('HTML injection preserves CSS styling', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  
  expect(result.chatWidgetCode).toContain('<style>');
  expect(result.chatWidgetCode).toContain(':host {');
  expect(result.chatWidgetCode).toContain('background: linear-gradient');
  expect(result.sidebarWidgetCode).toContain('<style>');
  expect(result.sidebarWidgetCode).toContain(':host {');
});

console.log('');
console.log('ğŸ”„ Testing Output Validation:');

await test('Final code is valid JavaScript/TypeScript', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  
  // Check for basic JavaScript validity markers
  expect(result.finalCode).toContain('class ');
  expect(result.finalCode).toContain('constructor()');
  expect(result.finalCode).toContain('extends BaseWidget');
  expect(result.finalCode).toContain('protected validate()');
  
  // Verify no template placeholders remain
  expect(result.finalCode).not.toContain('{{');
  expect(result.finalCode).not.toContain('}}');
});

await test('Generated code includes proper module exports', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  
  expect(result.finalCode).toContain('export default');
  expect(result.finalCode).toContain('ChatWidget');
  expect(result.finalCode).toContain('ContinuumSidebar');
});

await test('Generated code includes DOM ready handling', async () => {
  const result = await simulateTemplateProcessing('1.0.0');
  
  expect(result.finalCode).toContain('DOMContentLoaded');
  expect(result.finalCode).toContain('querySelector');
  expect(result.finalCode).toContain('continuum-sidebar');
  expect(result.finalCode).toContain('chat-widget');
});

console.log('');
console.log('ğŸ”„ Testing Error Handling:');

await test('Processing handles missing template gracefully', async () => {
  try {
    // Try to read a non-existent template
    await fs.readFile(join(templatesDir, 'non-existent.ts'), 'utf-8');
    throw new Error('Should have thrown an error for missing file');
  } catch (error) {
    expect(error.code).toBe('ENOENT');
  }
});

await test('Version injection handles special characters', async () => {
  const testVersion = '1.0.0-beta.1+build.123';
  const result = await simulateTemplateProcessing(testVersion);
  
  expect(result.finalCode).toContain(testVersion);
  expect(result.processedChatHTML).toContain(testVersion);
});

// Run all tests and report results
console.log('');
console.log('ğŸ“Š Layer 2 Test Results:');
console.log(`Total tests: ${testCount}`);
console.log(`âœ… Passed: ${passCount}`);
console.log(`âŒ Failed: ${failCount}`);
console.log(`Success rate: ${Math.round((passCount / testCount) * 100)}%`);

if (failCount === 0) {
  console.log('');
  console.log('ğŸ‰ Layer 2 RendererDaemon Template Processing: ALL TESTS PASSED');
  console.log('âœ… Ready to move to Layer 3: WebSocket Route Handling');
  process.exit(0);
} else {
  console.log('');
  console.log('âŒ Layer 2 RendererDaemon Template Processing: SOME TESTS FAILED');
  console.log('ğŸš« Fix daemon processing issues before proceeding to Layer 3');
  process.exit(1);
}