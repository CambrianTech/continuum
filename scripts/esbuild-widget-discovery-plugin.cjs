/**
 * esbuild Widget Discovery Plugin
 * 
 * Automatically discovers and includes widgets based on package.json declarations
 * Respects the same modular discovery system used by the command processor
 */

const fs = require('fs');
const path = require('path');

const widgetDiscoveryPlugin = {
  name: 'widget-discovery',
  setup(build) {
    // Handle the special 'widget-discovery' import
    build.onResolve({ filter: /^widget-discovery$/ }, (args) => {
      return {
        path: args.path,
        namespace: 'widget-discovery'
      };
    });

    // Generate widget imports when 'widget-discovery' is loaded
    build.onLoad({ filter: /.*/, namespace: 'widget-discovery' }, async (args) => {
      try {
        const widgets = await discoverWidgets('./src/ui/components');
        
        console.log(`üîç Widget Discovery Plugin: Found ${widgets.length} widgets`);
        widgets.forEach(widget => {
          console.log(`  üì¶ ${widget.name} (${widget.componentName}) - ${widget.path}`);
        });

        // Generate asset manifest to eliminate 404s
        const assetManifest = await generateAssetManifest(widgets);
        console.log(`üìÅ Asset Manifest: Generated for ${Object.keys(assetManifest).length} widgets`);

        // Generate import statements for both client and server components
        // Use absolute paths from src/ui/ directory
        const imports = widgets.map(widget => {
          const clientImport = `import '${widget.clientPath}';`;
          const serverImport = widget.serverPath ? `// Server: ${widget.serverPath}` : '';
          return `${clientImport}\n${serverImport}`;
        }).join('\n');

        const content = `
// Auto-generated widget imports and asset manifest
// This file is generated by esbuild-widget-discovery-plugin.js
// Do not edit manually - changes will be overwritten

${imports}

// Smart Asset Manifest - Only lists files that actually exist (Zero 404s!)
export const WIDGET_ASSETS = ${JSON.stringify(assetManifest, null, 2)};

// Make WIDGET_ASSETS globally available for widgets
window.WIDGET_ASSETS = WIDGET_ASSETS;

console.log('üé® Widget Discovery: ${widgets.length} widgets registered');
console.log('üìÅ Asset Manifest: Zero 404s guaranteed!', WIDGET_ASSETS);
`;

        return {
          contents: content,
          loader: 'ts',
          resolveDir: path.resolve('./src/ui')
        };
      } catch (error) {
        console.error('‚ùå Widget discovery failed:', error);
        return {
          contents: '// Widget discovery failed\nconsole.warn("Widget discovery failed during build");',
          loader: 'ts',
          resolveDir: path.resolve('./src/ui')
        };
      }
    });
  }
};

/**
 * Discover widgets using the same logic as the command processor
 * Scans for package.json files with continuum.type: "widget"
 */
async function discoverWidgets(componentsDir) {
  const widgets = [];
  
  try {
    const entries = await fs.promises.readdir(componentsDir, { withFileTypes: true });
    
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const widgetDir = path.join(componentsDir, entry.name);
        const packagePath = path.join(widgetDir, 'package.json');
        
        try {
          // Check if package.json exists
          await fs.promises.access(packagePath);
          
          // Read and parse package.json
          const packageContent = await fs.promises.readFile(packagePath, 'utf-8');
          const packageJson = JSON.parse(packageContent);
          
          // Check if this is a widget module
          if (packageJson.continuum?.type === 'widget') {
            const widgetName = packageJson.continuum.widgetName || entry.name;
            const componentName = packageJson.continuum.componentName || `${entry.name.toLowerCase()}-widget`;
            
            // Look for client-side component (TypeScript file)
            const clientPath = path.join(widgetDir, `${widgetName}.ts`);
            const clientExists = await fileExists(clientPath);
            
            // Look for server-side component if specified
            const serverFile = packageJson.continuum.serverComponent;
            const serverPath = serverFile ? path.join(widgetDir, serverFile) : null;
            const serverExists = serverPath ? await fileExists(serverPath) : false;
            
            if (clientExists) {
              widgets.push({
                name: widgetName,                 // This is the class name from package.json
                directoryName: entry.name,        // This is the actual directory name
                componentName,
                path: `./components/${entry.name}/${widgetName}.ts`,
                clientPath: `./components/${entry.name}/${widgetName}.ts`,
                serverPath: serverExists ? `./components/${entry.name}/${serverFile}` : null,
                packageJson
              });
            } else {
              console.warn(`‚ö†Ô∏è Widget ${widgetName} has package.json but no ${widgetName}.ts file`);
            }
          }
        } catch (error) {
          // Skip directories without package.json or invalid JSON
          continue;
        }
      }
    }
  } catch (error) {
    console.error('Failed to discover widgets:', error);
  }
  
  return widgets;
}

/**
 * Check if file exists
 */
async function fileExists(filePath) {
  try {
    await fs.promises.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Generate smart asset manifest - only includes files that actually exist
 * This eliminates ALL 404s by only attempting to load assets we know exist
 */
async function generateAssetManifest(widgets) {
  const manifest = {};
  
  for (const widget of widgets) {
    const widgetAssets = {
      css: [],
      html: [],
      js: []
    };
    
    // Get widget directory path - use actual directory name, not class name
    const widgetDir = path.resolve('./src/ui/components', widget.directoryName);
    
    try {
      // Read directory contents
      const files = await fs.promises.readdir(widgetDir);
      
      // Categorize actual files that exist
      for (const file of files) {
        const filePath = path.join(widgetDir, file);
        const stats = await fs.promises.stat(filePath);
        
        if (stats.isFile()) {
          if (file.endsWith('.css')) {
            widgetAssets.css.push(file);
          } else if (file.endsWith('.html')) {
            widgetAssets.html.push(file);
          } else if (file.endsWith('.js') && !file.includes('.min.')) {
            widgetAssets.js.push(file);
          }
        }
      }
      
      // Only include widget in manifest if it has assets
      // Use the class name as the key (widget.name) so widgets can find their assets
      if (widgetAssets.css.length > 0 || widgetAssets.html.length > 0 || widgetAssets.js.length > 0) {
        manifest[widget.name] = widgetAssets;
      }
      
    } catch (error) {
      console.warn(`‚ö†Ô∏è Could not scan assets for ${widget.name}:`, error.message);
    }
  }
  
  return manifest;
}

module.exports = { widgetDiscoveryPlugin };