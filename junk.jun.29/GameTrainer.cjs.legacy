/**
 * Game Trainer
 * Trains AI agents to play games through Academy system
 */

class GameTrainer {
  constructor(academy, gameManager) {
    this.academy = academy;
    this.gameManager = gameManager;
    this.trainingData = new Map(); // gameType -> training examples
  }

  /**
   * Train an AI to play a specific game
   */
  async trainGameAI(gameType, personaName, rounds = 10) {
    console.log(`ðŸŽ“ Training ${personaName} to play ${gameType} for ${rounds} rounds`);
    
    const trainingData = await this.generateGameTrainingData(gameType, rounds);
    
    // Create specialized persona for the game
    const gamePersona = await this.academy.trainNewPersona(
      personaName,
      `${gameType}_specialist`,
      trainingData,
      {
        specialization: `Expert ${gameType} player`,
        gameType: gameType,
        training_rounds: rounds
      }
    );

    console.log(`âœ… ${personaName} graduated as ${gameType} specialist!`);
    return gamePersona;
  }

  /**
   * Generate training data by simulating games
   */
  async generateGameTrainingData(gameType, rounds) {
    const trainingExamples = [];
    
    for (let i = 0; i < rounds; i++) {
      console.log(`ðŸŽ® Simulating training game ${i + 1}/${rounds}`);
      
      // Create a training game
      const game = this.gameManager.startGame(gameType, ['TrainerAI', 'OpponentAI']);
      const gameLog = await this.simulateGameForTraining(game);
      
      // Convert game log to training examples
      const examples = this.convertGameToTrainingData(gameLog, gameType);
      trainingExamples.push(...examples);
      
      // Clean up the game
      this.gameManager.endGame(game.id);
    }

    return trainingExamples;
  }

  /**
   * Simulate a complete game for training data
   */
  async simulateGameForTraining(game) {
    const gameLog = [];
    let moves = 0;
    const maxMoves = 50; // Prevent infinite games
    
    while (!game.getStatus().gameOver && moves < maxMoves) {
      const status = game.getStatus();
      const currentPlayer = status.currentPlayer;
      
      // Generate a move based on game type
      let move;
      if (game.type === 'tic-tac-toe') {
        move = this.generateTicTacToeMove(game);
      } else if (game.type === 'word-chain') {
        move = this.generateWordChainMove(game);
      }
      
      if (move) {
        const result = this.gameManager.makeMove(game.id, currentPlayer, move);
        
        gameLog.push({
          gameState: JSON.parse(JSON.stringify(status)),
          player: currentPlayer,
          move: move,
          result: result,
          moveNumber: moves + 1
        });
        
        if (!result.success) {
          console.log(`âš ï¸ Invalid move in training: ${result.message}`);
          break;
        }
      }
      
      moves++;
    }
    
    const finalStatus = game.getStatus();
    gameLog.push({
      gameState: finalStatus,
      gameResult: finalStatus.winner,
      totalMoves: moves
    });
    
    return gameLog;
  }

  /**
   * Generate strategic tic-tac-toe move
   */
  generateTicTacToeMove(game) {
    const board = game.board;
    
    // Strategy priority:
    // 1. Win if possible
    // 2. Block opponent from winning
    // 3. Take center if available
    // 4. Take corner
    // 5. Take edge
    
    const symbol = game.currentPlayer === 0 ? 'X' : 'O';
    const opponentSymbol = game.currentPlayer === 0 ? 'O' : 'X';
    
    // Check for winning move
    for (let i = 0; i < 9; i++) {
      if (board[i] === null) {
        board[i] = symbol;
        if (this.checkTicTacToeWin(board, symbol)) {
          board[i] = null; // Reset
          return (i + 1).toString(); // Return 1-based position
        }
        board[i] = null; // Reset
      }
    }
    
    // Check for blocking move
    for (let i = 0; i < 9; i++) {
      if (board[i] === null) {
        board[i] = opponentSymbol;
        if (this.checkTicTacToeWin(board, opponentSymbol)) {
          board[i] = null; // Reset
          return (i + 1).toString(); // Return 1-based position
        }
        board[i] = null; // Reset
      }
    }
    
    // Take center (position 5)
    if (board[4] === null) return '5';
    
    // Take corners (1, 3, 7, 9)
    const corners = [0, 2, 6, 8];
    for (const corner of corners) {
      if (board[corner] === null) {
        return (corner + 1).toString();
      }
    }
    
    // Take edges (2, 4, 6, 8)
    const edges = [1, 3, 5, 7];
    for (const edge of edges) {
      if (board[edge] === null) {
        return (edge + 1).toString();
      }
    }
    
    return null;
  }

  /**
   * Check if there's a winning combination
   */
  checkTicTacToeWin(board, symbol) {
    const lines = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
      [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
      [0, 4, 8], [2, 4, 6] // diagonals
    ];
    
    return lines.some(([a, b, c]) => 
      board[a] === symbol && board[b] === symbol && board[c] === symbol
    );
  }

  /**
   * Generate word for word chain
   */
  generateWordChainMove(game) {
    const words = game.words;
    const commonWords = [
      'apple', 'elephant', 'tiger', 'robot', 'table', 'energy', 'yellow', 'water',
      'radio', 'ocean', 'night', 'tree', 'eagle', 'lime', 'mouse', 'earth',
      'happy', 'yarn', 'nest', 'truck', 'kite', 'egg', 'green', 'nail'
    ];
    
    if (words.length === 0) {
      // First word - pick something common
      return commonWords[Math.floor(Math.random() * commonWords.length)];
    }
    
    const lastWord = words[words.length - 1];
    const requiredLetter = lastWord[lastWord.length - 1];
    
    // Find words that start with the required letter
    const validWords = commonWords.filter(word => 
      word[0] === requiredLetter && !words.includes(word)
    );
    
    if (validWords.length > 0) {
      return validWords[Math.floor(Math.random() * validWords.length)];
    }
    
    // Fallback: generate a simple word
    return requiredLetter + 'at';
  }

  /**
   * Convert game log to training examples
   */
  convertGameToTrainingData(gameLog, gameType) {
    const examples = [];
    
    gameLog.forEach((entry, index) => {
      if (entry.move) {
        const example = {
          input: `Game: ${gameType}\nState: ${JSON.stringify(entry.gameState)}\nPlayer: ${entry.player}`,
          output: `Move: ${entry.move}`,
          context: {
            gameType: gameType,
            moveNumber: entry.moveNumber,
            wasSuccessful: entry.result?.success || false
          }
        };
        
        // Add reasoning for good moves
        if (entry.result?.success) {
          if (entry.result.winner) {
            example.output += ` (Winning move!)`;
          } else if (gameType === 'tic-tac-toe') {
            example.output += ` (Strategic positioning)`;
          }
        }
        
        examples.push(example);
      }
    });
    
    return examples;
  }

  /**
   * Get training statistics
   */
  getTrainingStats(gameType) {
    const data = this.trainingData.get(gameType) || [];
    return {
      gameType: gameType,
      totalExamples: data.length,
      successfulMoves: data.filter(ex => ex.context?.wasSuccessful).length,
      winningMoves: data.filter(ex => ex.output.includes('Winning')).length
    };
  }
}

module.exports = GameTrainer;