/**
 * Chat Widget - TypeScript Web Component
 * Handles the main conversation interface and message management
 */
import { BaseWidget } from '../shared/BaseWidget.js';
export class ChatWidget extends BaseWidget {
    constructor() {
        super();
        this.messages = [];
        this.isTyping = false;
        this.messageIdCounter = 0;
        this.currentRoomId = 'general';
        this.isLoadingHistory = false;
        this.availableRooms = [
            {
                id: 'general',
                name: 'General Chat',
                description: 'General conversation with AI assistants',
                icon: 'ðŸ’¬',
                type: 'general'
            },
            {
                id: 'academy',
                name: 'Academy Training',
                description: 'AI training and persona development',
                icon: 'ðŸŽ“',
                type: 'academy'
            }
        ];
        this.widgetName = 'Chat';
        this.widgetIcon = 'ðŸ’¬';
        this.widgetTitle = 'Chat';
    }
    async connectedCallback() {
        await super.connectedCallback();
        await this.initializeChat();
        this.setupContinuumListeners();
    }
    // Public method to switch rooms
    async switchRoom(roomId) {
        if (this.currentRoomId === roomId)
            return;
        console.log(`ðŸ’¬ Chat: Switching from room ${this.currentRoomId} to ${roomId}`);
        this.currentRoomId = roomId;
        this.messages = [];
        
        // Update the room title
        this.updateRoomTitle();
        
        await this.loadRoomHistory();
        this.render();
    }
    async loadCSS() {
        const response = await fetch('/src/ui/components/Chat/styles.css');
        return await response.text();
    }
    async initializeChat() {
        console.log(`ðŸ’¬ Chat: Initializing chat for room: ${this.currentRoomId}`);
        
        // Update the room title
        this.updateRoomTitle();
        
        // Load room history first
        await this.loadRoomHistory();
        // If no messages, add welcome
        if (this.messages.length === 0) {
            this.addMessage({
                id: this.generateMessageId(),
                type: 'system',
                content: `Welcome to Continuum room: ${this.currentRoomId}! Start a conversation with your AI assistants.`,
                timestamp: new Date()
            });
        }
        // Focus input field
        setTimeout(() => {
            const input = this.shadowRoot?.querySelector('#messageInput');
            if (input) {
                input.focus();
            }
        }, 100);
    }
    async loadRoomHistory() {
        if (this.isLoadingHistory || !this.isContinuumConnected()) {
            console.log('ðŸ’¬ Chat: Skipping history load - already loading or not connected');
            return;
        }
        try {
            this.isLoadingHistory = true;
            console.log(`ðŸ’¬ Chat: Loading history for room: ${this.currentRoomId}`);
            const response = await this.executeCommand('chat_history', {
                roomId: this.currentRoomId,
                limit: 50 // Load last 50 messages
            });
            if (response && response.messages) {
                // Convert server messages to our format
                this.messages = response.messages.map((msg) => ({
                    id: msg.id || this.generateMessageId(),
                    type: msg.type || 'assistant',
                    content: msg.content || msg.message || '',
                    timestamp: new Date(msg.timestamp || msg.created || Date.now()),
                    metadata: {
                        agent: msg.agent,
                        persona: msg.persona
                    }
                }));
                console.log(`ðŸ’¬ Chat: Loaded ${this.messages.length} messages for room ${this.currentRoomId}`);
            }
            else {
                console.log(`ðŸ’¬ Chat: No history found for room ${this.currentRoomId}`);
            }
        }
        catch (error) {
            console.error(`ðŸ’¬ Chat: Failed to load history for room ${this.currentRoomId}:`, error);
            // Don't clear messages on error, keep what we have
        }
        finally {
            this.isLoadingHistory = false;
        }
    }
    setupContinuumListeners() {
        if (this.getContinuumAPI()) {
            // Real-time message streaming (event-driven)
            this.onContinuumEvent('message_received', (data) => {
                // Only handle messages for current room
                if (data.roomId === this.currentRoomId) {
                    console.log(`ðŸ’¬ Chat: Received message for room ${this.currentRoomId}`, data);
                    this.handleIncomingMessage(data);
                }
            });
            this.onContinuumEvent('agent_typing', (data) => {
                if (data.roomId === this.currentRoomId) {
                    console.log(`ðŸ’¬ Chat: Agent typing in room ${this.currentRoomId}`, data);
                    this.setTypingIndicator(true);
                }
            });
            this.onContinuumEvent('agent_stop_typing', (data) => {
                if (data.roomId === this.currentRoomId) {
                    console.log(`ðŸ’¬ Chat: Agent stopped typing in room ${this.currentRoomId}`);
                    this.setTypingIndicator(false);
                }
            });
            // Room switching events
            this.onContinuumEvent('room_switched', (data) => {
                if (data.roomId && data.roomId !== this.currentRoomId) {
                    console.log(`ðŸ’¬ Chat: Room switch requested: ${data.roomId}`);
                    this.switchRoom(data.roomId);
                }
            });
            console.log('ðŸ’¬ Chat: Connected to continuum API for room-based messaging');
        }
        else {
            setTimeout(() => this.setupContinuumListeners(), 1000);
        }
    }
    renderContent() {
        const currentRoom = this.availableRooms.find(room => room.id === this.currentRoomId);
        return `
      <div class="room-header">
        <div class="current-room">
          <span class="room-icon">${currentRoom?.icon || 'ðŸ’¬'}</span>
          <div class="room-info">
            <div class="room-name">${currentRoom?.name || this.currentRoomId}</div>
            <div class="room-description">${currentRoom?.description || 'Chat room'}</div>
          </div>
        </div>
        ${this.isLoadingHistory ? '<div class="loading-indicator">Loading history...</div>' : ''}
      </div>

      <div class="chat-container" id="chat-container">
        <div class="messages" id="messages">
          ${this.messages.length === 0 ? this.renderWelcome() : this.messages.map(msg => this.renderMessage(msg)).join('')}
          ${this.isTyping ? this.renderTypingIndicator() : ''}
        </div>
      </div>
      
      <div class="input-area">
        <div class="input-container">
          <textarea 
            id="messageInput" 
            class="input-field" 
            placeholder="Type your message in ${currentRoom?.name || this.currentRoomId}..." 
            rows="1"
          ></textarea>
          <button class="send-button" id="sendButton" title="Send message">âž¤</button>
        </div>
      </div>
    `;
    }
    renderWelcome() {
        return `
      <div class="welcome-message">
        <div class="welcome-title">Welcome to Continuum</div>
        <div class="welcome-subtitle">Your AI collaboration platform</div>
        <div class="quick-actions">
          <div class="quick-action" data-action="help">Help</div>
          <div class="quick-action" data-action="status">System Status</div>
          <div class="quick-action" data-action="screenshot">Take Screenshot</div>
          <div class="quick-action" data-action="personas">View Personas</div>
        </div>
      </div>
    `;
    }
    renderMessage(message) {
        const timeStr = message.timestamp.toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
        });
        const statusIcon = this.getStatusIcon(message.status);
        const agentName = message.metadata?.agent || message.metadata?.persona || 'System';
        return `
      <div class="message ${message.type}" data-message-id="${message.id}">
        <div class="message-content">${this.formatMessageContent(message.content)}</div>
        <div class="message-meta">
          ${message.type === 'assistant' ? `<span class="agent-name">${agentName}</span>` : ''}
          <span class="message-time">${timeStr}</span>
          ${message.status ? `<span class="message-status status-${message.status}">${statusIcon}</span>` : ''}
        </div>
      </div>
    `;
    }
    renderTypingIndicator() {
        return `
      <div class="message assistant">
        <div class="typing-indicator">
          <span>AI is thinking</span>
          <div class="typing-dots">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
          </div>
        </div>
      </div>
    `;
    }
    formatMessageContent(content) {
        // Basic markdown-like formatting
        return content
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            .replace(/\n/g, '<br>');
    }
    getStatusIcon(status) {
        switch (status) {
            case 'sending': return 'â³';
            case 'sent': return 'âœ“';
            case 'error': return 'âŒ';
            default: return '';
        }
    }
    setupEventListeners() {
        const input = this.shadowRoot?.querySelector('#messageInput');
        const sendButton = this.shadowRoot?.querySelector('#sendButton');
        if (input && sendButton) {
            // Auto-resize textarea
            input.addEventListener('input', () => {
                this.autoResizeTextarea(input);
            });
            // Send message on Enter (but allow Shift+Enter for newlines)
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendChatMessage();
                }
            });
            // Send button click
            sendButton.addEventListener('click', () => {
                this.sendChatMessage();
            });
        }
        // Quick action buttons
        this.shadowRoot?.querySelectorAll('.quick-action').forEach(action => {
            action.addEventListener('click', (e) => {
                const actionType = e.currentTarget.dataset.action;
                this.handleQuickAction(actionType);
            });
        });
    }
    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    async sendChatMessage() {
        const input = this.shadowRoot?.querySelector('#messageInput');
        const sendButton = this.shadowRoot?.querySelector('#sendButton');
        if (!input || !sendButton)
            return;
        const content = input.value.trim();
        if (!content)
            return;
        // Clear input and disable button
        input.value = '';
        input.style.height = 'auto';
        sendButton.disabled = true;
        // Add user message
        const userMessage = {
            id: this.generateMessageId(),
            type: 'user',
            content: content,
            timestamp: new Date(),
            status: 'sending'
        };
        this.addMessage(userMessage);
        try {
            // Send to continuum API with room ID
            await this.executeCommand('chat', {
                message: content,
                roomId: this.currentRoomId,
                timestamp: userMessage.timestamp.toISOString()
            });
            // Update message status
            this.updateMessageStatus(userMessage.id, 'sent');
        }
        catch (error) {
            console.error('ðŸ’¬ Chat: Failed to send message:', error);
            this.updateMessageStatus(userMessage.id, 'error');
            // Add error message
            this.addMessage({
                id: this.generateMessageId(),
                type: 'system',
                content: 'Failed to send message. Please try again.',
                timestamp: new Date()
            });
        }
        finally {
            sendButton.disabled = false;
            input.focus();
        }
    }
    handleIncomingMessage(data) {
        const message = {
            id: this.generateMessageId(),
            type: 'assistant',
            content: data.content || data.message || 'No response received',
            timestamp: new Date(data.timestamp || Date.now()),
            metadata: {
                agent: data.agent,
                persona: data.persona
            }
        };
        this.addMessage(message);
        this.setTypingIndicator(false);
    }
    handleQuickAction(action) {
        const quickMessages = {
            help: 'Help me understand how to use Continuum',
            status: 'Show me the system status',
            screenshot: 'Take a screenshot of the current interface',
            personas: 'Show me available AI personas'
        };
        const input = this.shadowRoot?.querySelector('#messageInput');
        if (input && quickMessages[action]) {
            input.value = quickMessages[action];
            input.focus();
            this.autoResizeTextarea(input);
        }
    }
    addMessage(message) {
        this.messages.push(message);
        this.render();
        this.scrollToBottom();
    }
    updateMessageStatus(messageId, status) {
        const message = this.messages.find(msg => msg.id === messageId);
        if (message) {
            message.status = status;
            this.render();
        }
    }
    setTypingIndicator(isTyping) {
        if (this.isTyping !== isTyping) {
            this.isTyping = isTyping;
            this.render();
            if (isTyping) {
                this.scrollToBottom();
            }
        }
    }
    scrollToBottom() {
        setTimeout(() => {
            const container = this.shadowRoot?.querySelector('#chat-container');
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        }, 0);
    }
    generateMessageId() {
        return `msg_${this.messageIdCounter++}_${Date.now()}`;
    }
    clearMessages() {
        this.messages = [];
        this.render();
    }
    addSystemMessage(content) {
        this.addMessage({
            id: this.generateMessageId(),
            type: 'system',
            content: content,
            timestamp: new Date()
        });
    }

    updateRoomTitle() {
        const currentRoom = this.availableRooms.find(room => room.id === this.currentRoomId);
        const roomName = currentRoom?.name || this.currentRoomId;
        
        // Emit clean event for other components to listen to
        const event = new CustomEvent('continuum:room-changed', {
            detail: {
                roomId: this.currentRoomId,
                roomName: roomName,
                roomIcon: currentRoom?.icon || 'ðŸ’¬'
            },
            bubbles: true
        });
        
        document.dispatchEvent(event);
        console.log(`ðŸ’¬ Chat: Room title updated to: ${roomName}`);
    }
}
// Register the custom element
if (!customElements.get('chat-widget')) {
    customElements.define('chat-widget', ChatWidget);
}
