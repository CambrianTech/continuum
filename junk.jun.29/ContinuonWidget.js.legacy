/**
 * ContinuonWidget - HAL 9000-style status orb with scrolling status feed
 * Shows system health, emotions, and live status updates
 */
import { BaseWidget } from '../shared/BaseWidget.js';
export class ContinuonWidget extends BaseWidget {
    constructor() {
        super();
        this.currentStatus = 'red';
        this.currentEmotion = null;
        this.statusFeed = [];
        this.maxStatusMessages = 5;
        this.widgetName = 'ContinuonWidget';
        this.widgetIcon = 'ðŸ”®';
        this.widgetTitle = 'System Status Orb';
        this.cssPath = '/src/ui/components/Continuon/ContinuonWidget.css';
    }
    async initializeWidget() {
        await this.loadCSS();
        this.setupEventListeners();
        this.setupStatusFeed();
        
        // Log version on startup
        const version = this.getSystemVersion();
        console.log(`ðŸš€ Continuum v${version} - ContinuonWidget initialized`);
        
        // Initial status
        this.addStatusMessage('System initializing...');
        this.updateStatus('yellow', 'Starting up...');
        this.render();
        
        // Set to green after a brief delay
        setTimeout(() => {
            this.updateStatus('green', 'System ready');
        }, 2000);
    }
    setupEventListeners() {
        // Listen for status changes
        document.addEventListener('continuum:status-change', (e) => {
            this.updateStatus(e.detail.status, e.detail.message);
        });
        // Listen for emotions
        document.addEventListener('continuum:emotion', (e) => {
            this.showEmotion(e.detail.emotion, e.detail.duration || 3000);
        });
        // Listen for system events
        document.addEventListener('continuum:system-event', (e) => {
            this.addStatusMessage(e.detail.message);
        });
    }
    renderContent() {
        const orbContent = this.currentEmotion || '';
        const statusColor = this.getStatusColor();
        return `
      <div class="continuon-container">
        <div class="continuon-orb-container">
          <div class="continuon-orb ${statusColor}" data-emotion="${this.currentEmotion || ''}">
            <div class="orb-ring"></div>
            <div class="orb-center">
              <span class="orb-emotion">${orbContent}</span>
            </div>
            <div class="orb-glow"></div>
          </div>
          <span class="continuon-label">continuum</span>
        </div>
        
        <div class="status-feed">
          <div class="status-messages">
            ${this.renderStatusMessages()}
          </div>
        </div>
      </div>
    `;
    }
    renderStatusMessages() {
        return this.statusFeed
            .slice(-this.maxStatusMessages)
            .map((msg, index) => `
        <div class="status-message fade-${index}" 
             style="animation-delay: ${index * 0.1}s">
          ${msg.text}
        </div>
      `).join('');
    }
    updateStatus(status, message) {
        if (this.currentStatus !== status) {
            this.currentStatus = status;
            if (message) {
                this.addStatusMessage(message);
            }
            // Update title and favicon
            this.updateTitleAndFavicon();
            this.render();
            // Log version only on status changes
            this.logVersionIfChanged();
        }
    }
    showEmotion(emotion, duration) {
        this.currentEmotion = emotion;
        // Update favicon to show emotion
        this.updateTitleAndFavicon();
        this.render();
        // Clear emotion after duration
        setTimeout(() => {
            this.currentEmotion = null;
            this.updateTitleAndFavicon(); // Restore status color
            this.render();
        }, duration);
    }
    addStatusMessage(text) {
        const message = {
            text,
            timestamp: Date.now(),
            id: Math.random().toString(36).substr(2, 9)
        };
        this.statusFeed.push(message);
        // Keep only recent messages
        if (this.statusFeed.length > this.maxStatusMessages * 2) {
            this.statusFeed = this.statusFeed.slice(-this.maxStatusMessages);
        }
        this.render();
    }
    getStatusColor() {
        switch (this.currentStatus) {
            case 'green': return 'status-healthy';
            case 'yellow': return 'status-degraded';
            case 'red': return 'status-error';
            default: return 'status-error';
        }
    }
    logVersionIfChanged() {
        // Only log version when status changes (not spam)
        const version = this.getSystemVersion();
        const lastVersion = localStorage.getItem('continuum-last-version');
        if (version && version !== lastVersion) {
            console.log(`ðŸš€ Continuum ${lastVersion ? `${lastVersion} â†’ ${version}` : `v${version}`}`);
            localStorage.setItem('continuum-last-version', version);
        }
    }
    getSystemVersion() {
        // Get version from continuum API or DOM
        const continuum = window.continuum;
        return continuum?.version || '0.2.2177';
    }
    setupStatusFeed() {
        // Connect to WebSocket events for live status updates
        const continuum = window.continuum;
        if (continuum) {
            // Listen for connection events
            continuum.on('connected', () => {
                this.updateStatus('green', 'Connected');
            });
            continuum.on('disconnected', () => {
                this.updateStatus('red', 'Disconnected');
            });
            continuum.on('reconnecting', () => {
                this.updateStatus('yellow', 'Reconnecting...');
            });
        }
    }
    updateTitleAndFavicon() {
        const displayIcon = this.currentEmotion || this.getStatusIcon();
        // Update favicon
        this.updateFavicon(displayIcon);
        // Update title (keep it simple)
        document.title = 'continuum';
    }
    getStatusIcon() {
        switch (this.currentStatus) {
            case 'green': return 'ðŸŸ¢';
            case 'yellow': return 'ðŸŸ¡';
            case 'red': return 'ðŸ”´';
            default: return 'ðŸ”´';
        }
    }
    updateFavicon(icon) {
        const favicon = document.getElementById('favicon');
        if (favicon) {
            const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>${icon}</text></svg>`;
            favicon.href = `data:image/svg+xml,${encodeURIComponent(svg)}`;
        }
    }
}
// Register the widget
customElements.define('continuon-widget', ContinuonWidget);
