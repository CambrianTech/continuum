#!/usr/bin/env node
/**
 * AI Greeting Test
 * Tests that AI actually greets users on connection (not canned responses)
 */

const WebSocket = require('ws');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Test configuration
const TEST_PORT = 5558; // Use different port to avoid conflicts
const TEST_TIMEOUT = 15000; // 15 seconds for AI to respond
const GREETING_KEYWORDS = ['hello', 'hi', 'welcome', 'greet', 'assist', 'help'];

let continuumProcess = null;
let testResults = {
  connectionEstablished: false,
  aiGreetingReceived: false,
  greetingFromRealAI: false,
  greetingContainsKeywords: false,
  greetingText: '',
  timeToGreeting: 0
};

// Cleanup function
function cleanup() {
  if (continuumProcess) {
    console.log('ðŸ§¹ Cleaning up Continuum process...');
    continuumProcess.kill('SIGTERM');
    continuumProcess = null;
  }
}

// Start Continuum instance for testing
async function startContinuum() {
  return new Promise((resolve, reject) => {
    console.log(`ðŸš€ Starting Continuum on port ${TEST_PORT}...`);
    
    continuumProcess = spawn('node', ['continuum.cjs', 'start', '--port', TEST_PORT.toString()], {
      stdio: 'pipe',
      env: { ...process.env, CONTINUUM_PORT: TEST_PORT.toString() }
    });
    
    let output = '';
    
    continuumProcess.stdout.on('data', (data) => {
      output += data.toString();
      console.log('ðŸ“„ Continuum:', data.toString().trim());
      
      // Wait for server to be ready
      if (output.includes(`Continuum ready: http://localhost:${TEST_PORT}`)) {
        console.log('âœ… Continuum server is ready');
        setTimeout(resolve, 2000); // Give it time to fully initialize
      }
    });
    
    continuumProcess.stderr.on('data', (data) => {
      console.log('âš ï¸  Continuum stderr:', data.toString().trim());
    });
    
    continuumProcess.on('error', (error) => {
      console.error('âŒ Failed to start Continuum:', error);
      reject(error);
    });
    
    // Timeout if server doesn't start
    setTimeout(() => {
      if (!output.includes('Continuum ready')) {
        reject(new Error('Continuum server failed to start within timeout'));
      }
    }, 10000);
  });
}

// Test WebSocket connection and AI greeting
async function testAIGreeting() {
  return new Promise((resolve, reject) => {
    console.log(`ðŸ”Œ Connecting to WebSocket at ws://localhost:${TEST_PORT}...`);
    
    const ws = new WebSocket(`ws://localhost:${TEST_PORT}`);
    const startTime = Date.now();
    let greetingReceived = false;
    
    ws.on('open', () => {
      console.log('âœ… WebSocket connection established');
      testResults.connectionEstablished = true;
    });
    
    ws.on('message', (data) => {
      try {
        const message = JSON.parse(data.toString());
        console.log('ðŸ“¨ Received message:', JSON.stringify(message, null, 2));
        
        // Look for AI greeting in result messages
        if (message.type === 'result' && message.data && message.data.result) {
          const greetingText = message.data.result.toString().toLowerCase();
          const timeToGreeting = Date.now() - startTime;
          
          console.log(`ðŸ¤– AI Response: "${message.data.result}"`);
          console.log(`â±ï¸  Time to greeting: ${timeToGreeting}ms`);
          
          testResults.aiGreetingReceived = true;
          testResults.greetingText = message.data.result;
          testResults.timeToGreeting = timeToGreeting;
          
          // Check if this came from a real AI (has role info)
          if (message.data.role && ['PlannerAI', 'CodeAI', 'GeneralAI'].includes(message.data.role)) {
            console.log(`âœ… Greeting came from real AI: ${message.data.role}`);
            testResults.greetingFromRealAI = true;
          }
          
          // Check if greeting contains expected keywords
          const foundKeywords = GREETING_KEYWORDS.filter(keyword => 
            greetingText.includes(keyword)
          );
          
          if (foundKeywords.length > 0) {
            console.log(`âœ… Greeting contains keywords: ${foundKeywords.join(', ')}`);
            testResults.greetingContainsKeywords = true;
          }
          
          greetingReceived = true;
          ws.close();
          resolve(testResults);
        }
        
        // Also check for status messages that might contain greetings
        if (message.type === 'status' && message.data && message.data.message) {
          console.log(`ðŸ“Š Status: ${message.data.message}`);
        }
        
      } catch (error) {
        console.log('âš ï¸  Failed to parse message:', data.toString());
      }
    });
    
    ws.on('error', (error) => {
      console.error('âŒ WebSocket error:', error);
      reject(error);
    });
    
    ws.on('close', () => {
      console.log('ðŸ”Œ WebSocket connection closed');
      if (!greetingReceived) {
        reject(new Error('No AI greeting received before connection closed'));
      }
    });
    
    // Timeout if no greeting received
    setTimeout(() => {
      if (!greetingReceived) {
        ws.close();
        reject(new Error(`No AI greeting received within ${TEST_TIMEOUT}ms`));
      }
    }, TEST_TIMEOUT);
  });
}

// Validate test results
function validateResults(results) {
  console.log('\nðŸ§ª VALIDATING TEST RESULTS:');
  console.log('============================');
  
  const tests = [
    {
      name: 'WebSocket Connection',
      passed: results.connectionEstablished,
      description: 'WebSocket connection established successfully'
    },
    {
      name: 'AI Greeting Received',
      passed: results.aiGreetingReceived,
      description: 'Received a message that appears to be an AI greeting'
    },
    {
      name: 'Real AI Response',
      passed: results.greetingFromRealAI,
      description: 'Greeting came from actual AI agent (not hardcoded)'
    },
    {
      name: 'Greeting Content Quality',
      passed: results.greetingContainsKeywords,
      description: 'Greeting contains appropriate welcoming keywords'
    },
    {
      name: 'Response Time',
      passed: results.timeToGreeting > 0 && results.timeToGreeting < TEST_TIMEOUT,
      description: `Greeting received within reasonable time (${results.timeToGreeting}ms)`
    }
  ];
  
  let passedTests = 0;
  
  tests.forEach(test => {
    const status = test.passed ? 'âœ… PASS' : 'âŒ FAIL';
    console.log(`  ${status} ${test.name}`);
    console.log(`     ${test.description}`);
    if (test.passed) passedTests++;
  });
  
  console.log(`\nðŸ“Š Results: ${passedTests}/${tests.length} tests passed`);
  
  if (results.greetingText) {
    console.log(`\nðŸ’¬ Actual greeting text: "${results.greetingText}"`);
  }
  
  return passedTests === tests.length;
}

// Main test runner
async function runAIGreetingTest() {
  console.log('ðŸ§ª AI GREETING CONNECTION TEST');
  console.log('===============================');
  console.log('Testing that AI actually greets users on connection (not canned responses)\n');
  
  try {
    // Start Continuum server
    await startContinuum();
    
    // Wait a bit more for AI system to fully initialize
    console.log('â³ Waiting for AI system to initialize...');
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Test AI greeting
    console.log('ðŸ¤– Testing AI greeting on connection...');
    const results = await testAIGreeting();
    
    // Validate results
    const allTestsPassed = validateResults(results);
    
    if (allTestsPassed) {
      console.log('\nðŸŽ‰ ALL TESTS PASSED!');
      console.log('\nâœ… VERIFICATION COMPLETE:');
      console.log('  - WebSocket connection works');
      console.log('  - AI responds to connection events');
      console.log('  - Greeting comes from real AI agent');
      console.log('  - Response time is reasonable');
      console.log('  - Greeting content is appropriate');
      console.log('\nðŸ—ï¸  ARCHITECTURE VALIDATED:');
      console.log('  - Event-driven AI greeting system');
      console.log('  - No hardcoded startup messages');
      console.log('  - Real AI response on user connection');
      
      cleanup();
      process.exit(0);
    } else {
      console.log('\nâŒ SOME TESTS FAILED');
      console.log('The AI greeting system needs improvement.');
      
      cleanup();
      process.exit(1);
    }
    
  } catch (error) {
    console.error('\nðŸ’¥ Test failed:', error.message);
    
    cleanup();
    process.exit(1);
  }
}

// Handle cleanup on exit
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);
process.on('exit', cleanup);

// Run the test
if (require.main === module) {
  runAIGreetingTest().catch(error => {
    console.error('Test runner failed:', error);
    cleanup();
    process.exit(1);
  });
}

module.exports = { runAIGreetingTest, validateResults };