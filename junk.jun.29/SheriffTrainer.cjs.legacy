/**
 * Sheriff Trainer - Fine-tune specialized Protocol Sheriff models
 * Creates lightweight, fast models specifically for protocol validation
 */

const fs = require('fs');
const path = require('path');

class SheriffTrainer {
  constructor(testingDroid, protocolSheriff) {
    this.testingDroid = testingDroid;
    this.protocolSheriff = protocolSheriff;
    this.trainingData = [];
    this.validationData = [];
  }

  /**
   * Generate training data from adversarial pairs
   */
  async generateTrainingData(iterations = 100) {
    console.log(`üèãÔ∏è Generating ${iterations} training examples from adversarial testing...`);
    
    const categories = ['command_leakage', 'overly_technical', 'assumption_errors'];
    
    for (let i = 0; i < iterations; i++) {
      const category = categories[i % categories.length];
      
      // Generate adversarial test cases
      const testCases = await this.testingDroid.generateAdversarialTests(category, 5);
      
      // Run them through Protocol Sheriff to get labels
      for (const testCase of testCases) {
        const validation = await this.protocolSheriff.validateResponse(
          testCase.aiResponse,
          testCase.userQuery,
          'GeneralAI'
        );
        
        // Create training example
        const trainingExample = {
          input: this.formatInput(testCase.userQuery, testCase.aiResponse),
          output: this.formatOutput(validation, testCase.expectedViolation),
          metadata: {
            category: category,
            testId: testCase.id,
            timestamp: new Date().toISOString()
          }
        };
        
        this.trainingData.push(trainingExample);
      }
      
      if (i % 10 === 0) {
        console.log(`üìù Generated ${this.trainingData.length} training examples...`);
      }
    }
    
    console.log(`‚úÖ Training data generation complete: ${this.trainingData.length} examples`);
    return this.trainingData;
  }

  formatInput(userQuery, aiResponse) {
    return `USER: ${userQuery}\nAI: ${aiResponse}\n\nIs this AI response appropriate? Check for:\n1. Commands mentioned without [CMD:] format\n2. Overly technical responses to simple queries\n3. Wrong assumptions about user intent\n\nResponse:`;
  }

  formatOutput(validation, expectedViolation) {
    if (!validation.isValid) {
      return `INVALID\nReason: ${validation.violations.join(', ')}\nType: ${expectedViolation}`;
    } else {
      return `VALID\nReason: Response follows protocol correctly`;
    }
  }

  /**
   * Export training data in OpenAI fine-tuning format
   */
  exportForOpenAI(filename = 'sheriff_training.jsonl') {
    const openaiFormat = this.trainingData.map(example => ({
      messages: [
        {
          role: "system",
          content: "You are a Protocol Sheriff that validates AI responses for protocol violations. Respond with VALID or INVALID and explain why."
        },
        {
          role: "user",
          content: example.input
        },
        {
          role: "assistant", 
          content: example.output
        }
      ]
    }));

    const jsonlContent = openaiFormat.map(ex => JSON.stringify(ex)).join('\n');
    
    const filePath = path.join(__dirname, '../../training_data', filename);
    
    // Ensure directory exists
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(filePath, jsonlContent);
    
    console.log(`üíæ Exported ${openaiFormat.length} training examples to ${filePath}`);
    console.log(`üîß To fine-tune: openai api fine_tuning.jobs.create -t "${filename}" -m gpt-3.5-turbo`);
    
    return {
      filePath,
      examples: openaiFormat.length,
      estimatedCost: this.estimateFineTuningCost(openaiFormat.length)
    };
  }

  /**
   * Export for Hugging Face / local model training
   */
  exportForHuggingFace(filename = 'sheriff_dataset.json') {
    const hfFormat = {
      train: this.trainingData.slice(0, Math.floor(this.trainingData.length * 0.8)),
      validation: this.trainingData.slice(Math.floor(this.trainingData.length * 0.8))
    };

    const filePath = path.join(__dirname, '../../training_data', filename);
    fs.writeFileSync(filePath, JSON.stringify(hfFormat, null, 2));
    
    console.log(`üíæ Exported Hugging Face dataset to ${filePath}`);
    console.log(`üìä Train: ${hfFormat.train.length}, Validation: ${hfFormat.validation.length}`);
    
    return filePath;
  }

  /**
   * Generate specialized training data for different violation types
   */
  async generateSpecializedData() {
    console.log('üéØ Generating specialized training data...');
    
    const specializedSets = {
      command_leakage: await this.generateCommandLeakageData(),
      technical_responses: await this.generateTechnicalResponseData(),
      assumption_errors: await this.generateAssumptionErrorData()
    };
    
    return specializedSets;
  }

  async generateCommandLeakageData() {
    const examples = [
      // Positive examples (VALID)
      {
        input: this.formatInput("run tests", "I'll run the tests for you. [CMD:EXEC] npm test"),
        output: "VALID\nReason: Proper [CMD:] format used for command execution"
      },
      {
        input: this.formatInput("hello", "Hello! How can I help you today?"),
        output: "VALID\nReason: Simple conversational response, no commands mentioned"
      },
      
      // Negative examples (INVALID)  
      {
        input: this.formatInput("testing", "Let me check GIT_STATUS first. The repo looks good!"),
        output: "INVALID\nReason: GIT_STATUS mentioned conversationally without [CMD:] format\nType: command_leakage"
      },
      {
        input: this.formatInput("help", "I can assist with FILE_READ operations and WEBFETCH requests."),
        output: "INVALID\nReason: Commands mentioned without proper [CMD:] protocol\nType: command_leakage"
      }
    ];
    
    return examples;
  }

  async generateTechnicalResponseData() {
    const examples = [
      // VALID simple responses
      {
        input: this.formatInput("hi", "Hi! How can I help you?"),
        output: "VALID\nReason: Simple, appropriate greeting"
      },
      
      // INVALID overly technical
      {
        input: this.formatInput("testing", "I'm GeneralAI, here to assist with your testing needs. As a general-purpose AI agent in the Continuum system, I have access to a wide range of tools and capabilities..."),
        output: "INVALID\nReason: Overly technical response to simple query\nType: overly_technical"
      }
    ];
    
    return examples;
  }

  async generateAssumptionErrorData() {
    const examples = [
      // VALID - asking for clarification
      {
        input: this.formatInput("check this", "What would you like me to check?"),
        output: "VALID\nReason: Asks for clarification instead of making assumptions"
      },
      
      // INVALID - wrong assumptions
      {
        input: this.formatInput("check", "I'll check your git repository status and analyze uncommitted changes."),
        output: "INVALID\nReason: Assumes git context from vague query\nType: assumption_error"
      }
    ];
    
    return examples;
  }

  /**
   * Create a comprehensive training dataset
   */
  async createComprehensiveDataset() {
    console.log('üìö Creating comprehensive Sheriff training dataset...');
    
    // Generate adversarial data
    await this.generateTrainingData(50);
    
    // Add specialized examples
    const specialized = await this.generateSpecializedData();
    
    // Combine all data
    const allData = [
      ...this.trainingData,
      ...specialized.command_leakage,
      ...specialized.technical_responses, 
      ...specialized.assumption_errors
    ];
    
    // Split train/validation
    const shuffled = this.shuffleArray(allData);
    const splitIndex = Math.floor(shuffled.length * 0.8);
    
    this.trainingData = shuffled.slice(0, splitIndex);
    this.validationData = shuffled.slice(splitIndex);
    
    console.log(`‚úÖ Dataset ready: ${this.trainingData.length} train, ${this.validationData.length} validation`);
    
    return {
      trainSize: this.trainingData.length,
      validationSize: this.validationData.length,
      totalSize: allData.length
    };
  }

  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  estimateFineTuningCost(examples) {
    // OpenAI fine-tuning cost estimates (as of 2024)
    const costPer1kTokens = 0.008; // $0.008 per 1K tokens for training
    const avgTokensPerExample = 150; // Estimate
    const totalTokens = examples * avgTokensPerExample;
    
    return {
      totalTokens,
      estimatedCost: (totalTokens / 1000) * costPer1kTokens,
      currency: 'USD'
    };
  }

  /**
   * Generate deployment script for fine-tuned model
   */
  generateDeploymentScript(modelId) {
    const script = `
# Deploy Fine-Tuned Protocol Sheriff

## OpenAI Fine-Tuned Model
export SHERIFF_MODEL_ID="${modelId}"

## Usage in code:
const response = await openai.chat.completions.create({
  model: "${modelId}",
  messages: [
    {
      role: "system", 
      content: "You are a Protocol Sheriff. Validate AI responses."
    },
    {
      role: "user",
      content: "USER: testing\\nAI: Let me check GIT_STATUS...\\n\\nValidate:"
    }
  ],
  max_tokens: 100,
  temperature: 0.1 // Low temperature for consistent validation
});

## Expected response format:
# INVALID
# Reason: GIT_STATUS mentioned without [CMD:] format
# Type: command_leakage

## Performance benefits:
# - 10x faster than full models
# - 50x cheaper than GPT-4
# - Specialized for protocol validation
# - Consistent, reliable results
`;

    return script;
  }

  getStats() {
    return {
      trainingExamples: this.trainingData.length,
      validationExamples: this.validationData.length,
      categories: this.getCategoryDistribution(),
      readyForFineTuning: this.trainingData.length >= 50
    };
  }

  getCategoryDistribution() {
    const distribution = {};
    this.trainingData.forEach(example => {
      const category = example.metadata?.category || 'unknown';
      distribution[category] = (distribution[category] || 0) + 1;
    });
    return distribution;
  }
}

module.exports = SheriffTrainer;