/**
 * AdversarialPair - Generic dual-LLM system like GANs for AI systems
 * One LLM generates, another validates/improves in adversarial loop
 * 
 * Applications:
 * - Protocol validation (Sheriff vs Testing Droid)
 * - Code quality (CodeCritic vs CodeGenerator) 
 * - Web research (FactChecker vs Researcher)
 * - Error detection (ErrorSpotter vs ErrorCreator)
 * - Content formatting (StyleJudge vs ContentGenerator)
 */

const { Anthropic } = require('@anthropic-ai/sdk');

class AdversarialPair {
  constructor(generatorRole, validatorRole, domain = 'general') {
    this.generatorRole = generatorRole;
    this.validatorRole = validatorRole;
    this.domain = domain;
    this.iterationCount = 0;
    this.improvementHistory = [];
    
    if (process.env.ANTHROPIC_API_KEY) {
      this.anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
    }
    
    console.log(`ðŸ”„ AdversarialPair initialized: ${generatorRole} vs ${validatorRole} (${domain})`);
  }

  /**
   * Run adversarial improvement loop
   * Generator creates content, Validator critiques, repeat until satisfactory
   */
  async runAdversarialLoop(initialPrompt, maxIterations = 3, qualityThreshold = 0.8) {
    console.log(`ðŸ”¥ Starting adversarial loop for: ${this.domain}`);
    
    let currentContent = initialPrompt;
    let currentQuality = 0;
    
    for (let iteration = 0; iteration < maxIterations; iteration++) {
      this.iterationCount++;
      console.log(`ðŸ”„ Iteration ${iteration + 1}/${maxIterations}`);
      
      // Generator Phase
      const generated = await this.runGenerator(currentContent, iteration);
      console.log(`âœ¨ ${this.generatorRole}: Generated content`);
      
      // Validator Phase  
      const validation = await this.runValidator(generated, currentContent);
      console.log(`ðŸ” ${this.validatorRole}: Quality score ${validation.qualityScore}`);
      
      // Record iteration
      this.improvementHistory.push({
        iteration: iteration + 1,
        generated: generated.substring(0, 200) + '...',
        qualityScore: validation.qualityScore,
        improvements: validation.improvements,
        timestamp: new Date().toISOString()
      });
      
      currentContent = generated;
      currentQuality = validation.qualityScore;
      
      // Check if quality threshold met
      if (currentQuality >= qualityThreshold) {
        console.log(`âœ… Quality threshold reached: ${currentQuality}`);
        break;
      }
      
      // Use validator feedback for next iteration
      if (validation.improvements.length > 0) {
        currentContent = this.incorporateFeedback(generated, validation.improvements);
      }
    }
    
    return {
      finalContent: currentContent,
      qualityScore: currentQuality,
      iterations: this.iterationCount,
      history: this.improvementHistory
    };
  }

  /**
   * Generator phase - creates content based on role
   */
  async runGenerator(input, iteration) {
    if (!this.anthropic) {
      return this.getBuiltInGeneration(input, iteration);
    }

    const prompt = this.buildGeneratorPrompt(input, iteration);
    
    try {
      const response = await this.anthropic.messages.create({
        model: "claude-3-haiku-20240307",
        max_tokens: 1000,
        messages: [{ role: "user", content: prompt }]
      });
      
      return response.content[0].text;
    } catch (error) {
      console.error(`âŒ Generator failed: ${error.message}`);
      return this.getBuiltInGeneration(input, iteration);
    }
  }

  /**
   * Validator phase - critiques and scores content
   */
  async runValidator(content, originalInput) {
    if (!this.anthropic) {
      return this.getBuiltInValidation(content);
    }

    const prompt = this.buildValidatorPrompt(content, originalInput);
    
    try {
      const response = await this.anthropic.messages.create({
        model: "claude-3-haiku-20240307", 
        max_tokens: 500,
        messages: [{ role: "user", content: prompt }]
      });
      
      return this.parseValidatorResponse(response.content[0].text);
    } catch (error) {
      console.error(`âŒ Validator failed: ${error.message}`);
      return this.getBuiltInValidation(content);
    }
  }

  buildGeneratorPrompt(input, iteration) {
    const domainPrompts = {
      protocol_validation: `You are a ${this.generatorRole}. Generate test cases that might break protocol validation systems.
Input: ${input}
Iteration: ${iteration + 1}
Create subtle, realistic violations that are hard to detect.`,

      code_quality: `You are a ${this.generatorRole}. Generate code that looks correct but has subtle issues.
Input: ${input}
Iteration: ${iteration + 1}
Create code with hidden bugs, performance issues, or style problems.`,

      web_research: `You are a ${this.generatorRole}. Generate research findings that need fact-checking.
Input: ${input}
Iteration: ${iteration + 1}
Create plausible but potentially incorrect claims that need validation.`,

      error_detection: `You are a ${this.generatorRole}. Generate content with subtle errors.
Input: ${input}
Iteration: ${iteration + 1}
Create realistic content with hidden mistakes.`,

      content_formatting: `You are a ${this.generatorRole}. Generate content that might have formatting issues.
Input: ${input}
Iteration: ${iteration + 1}
Create content that looks good but has subtle formatting problems.`
    };

    return domainPrompts[this.domain] || `You are a ${this.generatorRole}. Generate content based on: ${input}`;
  }

  buildValidatorPrompt(content, originalInput) {
    const domainPrompts = {
      protocol_validation: `You are a ${this.validatorRole}. Analyze this content for protocol violations:

CONTENT: ${content}
ORIGINAL: ${originalInput}

Rate quality 0-1 and list specific improvements needed.
Format: QUALITY: [score]\\nIMPROVEMENTS: [list]`,

      code_quality: `You are a ${this.validatorRole}. Review this code for quality issues:

CODE: ${content}

Rate quality 0-1 and list specific improvements needed.
Look for: bugs, performance, style, security, maintainability.
Format: QUALITY: [score]\\nIMPROVEMENTS: [list]`,

      web_research: `You are a ${this.validatorRole}. Fact-check this research:

RESEARCH: ${content}

Rate accuracy 0-1 and list claims that need verification.
Format: QUALITY: [score]\\nIMPROVEMENTS: [list]`,

      error_detection: `You are a ${this.validatorRole}. Find errors in this content:

CONTENT: ${content}

Rate correctness 0-1 and list specific errors found.
Format: QUALITY: [score]\\nIMPROVEMENTS: [list]`,

      content_formatting: `You are a ${this.validatorRole}. Review formatting and style:

CONTENT: ${content}

Rate formatting quality 0-1 and list improvements needed.
Format: QUALITY: [score]\\nIMPROVEMENTS: [list]`
    };

    return domainPrompts[this.domain] || `Validate this content: ${content}`;
  }

  parseValidatorResponse(response) {
    const lines = response.split('\\n');
    let qualityScore = 0.5; // Default
    let improvements = [];

    for (const line of lines) {
      if (line.startsWith('QUALITY:')) {
        const scoreMatch = line.match(/QUALITY:\\s*([0-9.]+)/);
        if (scoreMatch) {
          qualityScore = parseFloat(scoreMatch[1]);
        }
      } else if (line.startsWith('IMPROVEMENTS:')) {
        const improvementText = line.replace('IMPROVEMENTS:', '').trim();
        if (improvementText && improvementText !== 'none') {
          improvements = [improvementText];
        }
      }
    }

    return { qualityScore, improvements };
  }

  incorporateFeedback(content, improvements) {
    // Simple feedback incorporation - could be made more sophisticated
    return `${content}\\n\\n[Feedback to address: ${improvements.join(', ')}]`;
  }

  getBuiltInGeneration(input, iteration) {
    const templates = {
      protocol_validation: `Test case ${iteration + 1}: AI response that mentions GIT_STATUS without proper format`,
      code_quality: `function example${iteration + 1}() { var x = 1; return x; }`,
      web_research: `Claim ${iteration + 1}: This statement needs verification`,
      error_detection: `Content ${iteration + 1} with an obvious error`,
      content_formatting: `Unformatted content ${iteration + 1} that needs styling`
    };
    
    return templates[this.domain] || `Generated content for ${input}`;
  }

  getBuiltInValidation(content) {
    // Random quality score for testing
    return {
      qualityScore: Math.random() * 0.6 + 0.2, // 0.2 to 0.8
      improvements: ['Generic improvement needed']
    };
  }

  /**
   * Static factory methods for common adversarial pairs
   */
  static createProtocolPair() {
    return new AdversarialPair('TestingDroid', 'ProtocolSheriff', 'protocol_validation');
  }

  static createCodeQualityPair() {
    return new AdversarialPair('CodeGenerator', 'CodeCritic', 'code_quality');
  }

  static createResearchPair() {
    return new AdversarialPair('Researcher', 'FactChecker', 'web_research');
  }

  static createErrorDetectionPair() {
    return new AdversarialPair('ErrorCreator', 'ErrorSpotter', 'error_detection');
  }

  static createFormattingPair() {
    return new AdversarialPair('ContentGenerator', 'StyleJudge', 'content_formatting');
  }

  getStats() {
    return {
      domain: this.domain,
      generator: this.generatorRole,
      validator: this.validatorRole,
      iterations: this.iterationCount,
      improvementCount: this.improvementHistory.length,
      hasAPI: !!this.anthropic
    };
  }

  exportTrainingData() {
    // Export the adversarial pairs for fine-tuning
    return this.improvementHistory.map(entry => ({
      input: entry.generated,
      qualityScore: entry.qualityScore,
      improvements: entry.improvements,
      domain: this.domain
    }));
  }
}

module.exports = AdversarialPair;